<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GeoJSON åœ°å›¾ç¼–è¾‘å™¨</title>
    <!-- FontAwesome 6 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
        crossorigin="anonymous" />
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
    <!-- Leaflet.draw CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"
        crossorigin="" />
    <!-- Custom Styles -->
    <style>
body {
    margin: 0;
    padding: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: #121212;
    color: #e0e0e0;
    display: flex;
    height: 100vh;
    overflow: hidden;
}

#map {
    flex-grow: 1;
    height: 100%;
    z-index: 1;
}

.panel {
    width: 250px;
    background: #1e1e1e;
    padding: 15px;
    box-shadow: 2px 0 5px rgba(0, 0, 0, 0.5);
    z-index: 2000;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
}

#controls {
    border-right: 1px solid #333;
}

#layerPanel {
    border-left: 1px solid #333;
    display: none;
    /* Hidden by default, toggled by button */
}

/* Editor Panel Overlay */
#editorPanel {
    position: absolute;
    bottom: 20px;
    left: 340px;
    right: 20px;
    height: 400px;
    background: rgba(30, 30, 30, 0.98);
    backdrop-filter: blur(10px);
    border: 1px solid #444;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.5);
    z-index: 1001;
    display: flex;
    flex-direction: column;
}

#geojsonEditor {
    width: 100%;
    height: 300px;
    background: #121212;
    color: #f0f0f0;
    border: 1px solid #444;
    border-radius: 6px;
    padding: 10px;
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    font-size: 0.9rem;
    resize: none;
    margin-bottom: 15px;
    flex-grow: 1;
    line-height: 1.5;
}

.panel h2 {
    margin-top: 0;
    font-size: 1.1rem;
    color: #fff;
    text-align: center;
    margin-bottom: 15px;
    font-weight: 600;
    letter-spacing: 0.5px;
}

.control-group {
    margin-bottom: 15px;
    display: flex;
    flex-direction: column;
}

.control-group label {
    font-size: 0.85rem;
    margin-bottom: 6px;
    color: #aaa;
}

.control-group select,
.control-group input[type="file"],
.control-group input[type="number"],
.control-group input[type="text"],
.control-group button {
    padding: 8px 10px;
    border: none;
    border-radius: 6px;
    font-size: 0.9rem;
    outline: none;
}

.control-group select,
.control-group input[type="number"],
.control-group input[type="text"] {
    background: #2c2c2c;
    color: #e0e0e0;
    border: 1px solid #444;
    transition: border-color 0.2s;
}

.control-group select:focus,
.control-group input:focus {
    border-color: #4a90e2;
}

.control-group button {
    background: #4a90e2;
    color: #fff;
    cursor: pointer;
    transition: all 0.2s;
    font-weight: 500;
}

.control-group button:hover {
    background: #357ab8;
    transform: translateY(-1px);
}

.control-group button:active {
    transform: translateY(0);
}

.control-group input[type="checkbox"] {
    margin-right: 8px;
    cursor: pointer;
}

/* Layer list items */
#layerList {
    max-height: calc(100vh - 100px);
    overflow-y: auto;
}

.layer-item {
    background: rgba(255, 255, 255, 0.03);
    padding: 10px;
    margin-bottom: 8px;
    border-radius: 6px;
    border-left: 3px solid #4a90e2;
    font-size: 0.85rem;
    transition: background 0.2s;
}

.layer-item:hover {
    background: rgba(255, 255, 255, 0.06);
}

.layer-item-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
}

.layer-name {
    font-weight: 600;
    color: #f0f0f0;
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-right: 8px;
}

.layer-type {
    font-size: 0.75rem;
    color: #888;
    background: rgba(0, 0, 0, 0.2);
    padding: 2px 6px;
    border-radius: 4px;
}

.layer-actions {
    display: flex;
    gap: 6px;
}

.layer-btn {
    padding: 4px 8px;
    font-size: 0.75rem;
    background: rgba(255, 255, 255, 0.1);
    border: none;
    border-radius: 4px;
    color: #ccc;
    cursor: pointer;
    transition: all 0.2s;
}

.layer-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    color: #fff;
}

.layer-btn.delete {
    background: rgba(231, 76, 60, 0.2);
    color: #e74c3c;
}

.layer-btn.delete:hover {
    background: #e74c3c;
    color: #fff;
}

/* Leaflet map container adjustments */
.leaflet-container {
    background: #0e0e0e;
}

/* Divider */
.divider {
    border: 0;
    height: 1px;
    background: linear-gradient(to right, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0));
    margin: 20px 0;
}

/* Scrollbar styling */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.1);
}

::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.15);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.25);
}

/* Layer labels */
.layer-label {
    background: rgba(0, 0, 0, 0.8) !important;
    border: 1px solid rgba(255, 255, 255, 0.2) !important;
    border-radius: 4px !important;
    color: #fff !important;
    font-size: 0.85rem !important;
    padding: 4px 8px !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5) !important;
    font-family: 'Segoe UI', sans-serif !important;
}

.layer-label::before {
    border-top-color: rgba(0, 0, 0, 0.8) !important;
    line-height: 1.5;
}

.panel h2 {
    margin-top: 0;
    font-size: 1.1rem;
    color: #fff;
    text-align: center;
    margin-bottom: 15px;
    font-weight: 600;
    letter-spacing: 0.5px;
}

.control-group {
    margin-bottom: 15px;
    display: flex;
    flex-direction: column;
}

.control-group label {
    font-size: 0.85rem;
    margin-bottom: 6px;
    color: #aaa;
}

.control-group select,
.control-group input[type="file"],
.control-group input[type="number"],
.control-group input[type="text"],
.control-group button {
    padding: 8px 10px;
    border: none;
    border-radius: 6px;
    font-size: 0.9rem;
    outline: none;
}

.control-group select,
.control-group input[type="number"],
.control-group input[type="text"] {
    background: #2c2c2c;
    color: #e0e0e0;
    border: 1px solid #444;
    transition: border-color 0.2s;
}

.control-group select:focus,
.control-group input:focus {
    border-color: #4a90e2;
}

.control-group button {
    background: #4a90e2;
    color: #fff;
    cursor: pointer;
    transition: all 0.2s;
    font-weight: 500;
}

.control-group button:hover {
    background: #357ab8;
    transform: translateY(-1px);
}

.control-group button:active {
    transform: translateY(0);
}

.control-group input[type="checkbox"] {
    margin-right: 8px;
    cursor: pointer;
}

/* Layer list items */
#layerList {
    max-height: calc(100vh - 100px);
    overflow-y: auto;
}

.layer-item {
    background: rgba(255, 255, 255, 0.03);
    padding: 10px;
    margin-bottom: 8px;
    border-radius: 6px;
    border-left: 3px solid #4a90e2;
    font-size: 0.85rem;
    transition: background 0.2s;
}

.layer-item:hover {
    background: rgba(255, 255, 255, 0.06);
}

.layer-item-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
}

.layer-name {
    font-weight: 600;
    color: #f0f0f0;
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-right: 8px;
}

.layer-type {
    font-size: 0.75rem;
    color: #888;
    background: rgba(0, 0, 0, 0.2);
    padding: 2px 6px;
    border-radius: 4px;
}

.layer-actions {
    display: flex;
    gap: 6px;
}

.layer-btn {
    padding: 4px 8px;
    font-size: 0.75rem;
    background: rgba(255, 255, 255, 0.1);
    border: none;
    border-radius: 4px;
    color: #ccc;
    cursor: pointer;
    transition: all 0.2s;
}

.layer-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    color: #fff;
}

.layer-btn.delete {
    background: rgba(231, 76, 60, 0.2);
    color: #e74c3c;
}

.layer-btn.delete:hover {
    background: #e74c3c;
    color: #fff;
}

/* Leaflet map container adjustments */
.leaflet-container {
    background: #0e0e0e;
}

/* Divider */
.divider {
    border: 0;
    height: 1px;
    background: linear-gradient(to right, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0));
    margin: 20px 0;
}

/* Scrollbar styling */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.1);
}

::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.15);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.25);
}

/* Layer labels */
.layer-label {
    background: rgba(0, 0, 0, 0.8) !important;
    border: 1px solid rgba(255, 255, 255, 0.2) !important;
    border-radius: 4px !important;
    color: #fff !important;
    font-size: 0.85rem !important;
    padding: 4px 8px !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5) !important;
    font-family: 'Segoe UI', sans-serif !important;
}

.layer-label::before {
    border-top-color: rgba(0, 0, 0, 0.8) !important;
}

/* Context Menu */
.context-menu {
    position: absolute;
    background: rgba(35, 35, 35, 0.98);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 8px;
    padding: 6px 0;
    min-width: 160px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
    z-index: 10000;
}

.context-menu-item {
    padding: 10px 16px;
    cursor: pointer;
    color: #e0e0e0;
    font-size: 0.9rem;
    transition: all 0.2s;
    display: flex;
    align-items: center;
}

.context-menu-item:hover {
    background: rgba(74, 144, 226, 0.2);
    color: #fff;
}

/* Leaflet Draw Toolbar Icon Styling - Normal Colors */
.leaflet-draw-toolbar a,
.leaflet-draw-actions a {
    background-color: #f4f4f4 !important;
    border: 1px solid #aaa !important;
    color: #333 !important;
    text-decoration: none !important;
}

.leaflet-draw-toolbar a:hover,
.leaflet-draw-actions a:hover {
    background-color: #fff !important;
}

/* Disabled state */
.leaflet-draw-toolbar .leaflet-disabled {
    background-color: rgba(200, 200, 200, 0.5) !important;
    border-color: rgba(100, 100, 100, 0.3) !important;
}

.leaflet-draw-toolbar .leaflet-disabled>* {
    opacity: 0.5 !important;
}

/* Custom Marker Icon Container */
.custom-marker-icon {
    background: transparent !important;
    border: none !important;
}

.custom-marker-wrapper {
    position: relative;
    width: 30px;
    height: 42px;
}

.custom-marker-circle {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
    border: 2px solid rgba(255, 255, 255, 0.9);
    position: relative;
    z-index: 2;
    transition: transform 0.2s;
}

.custom-marker-circle:hover {
    transform: scale(1.1);
}

.custom-marker-circle i {
    color: white;
    font-size: 14px;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

.custom-marker-tip {
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 6px solid transparent;
    border-right: 6px solid transparent;
    border-top: 10px solid;
    z-index: 1;
    filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.3));
}

/* ===== Event Tracker Panel ===== */
#eventTrackerPanel {
    width: 320px;
    border-left: 1px solid #333;
    display: none;
}


.panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.panel-header h2 {
    margin: 0;
    font-size: 1.2rem;
    font-weight: 600;
    letter-spacing: 0.5px;
    flex: 1;
}

#closeEventTrackerBtn {
    background: #e74c3c;
    border: none;
    color: white;
    padding: 8px 16px;
    border-radius: 4px;
    transition: all 0.2s;
    font-size: 0.9rem;
    cursor: pointer;
    font-weight: 500;
    z-index: 10;
    position: relative;
}

#closeEventTrackerBtn:hover {
    background: #c0392b;
    transform: translateY(-1px);
}


.tracker-section {
    margin-bottom: 25px;
}

.tracker-section h3 {
    font-size: 0.9rem;
    color: #4a90e2;
    margin: 0 0 12px 0;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* Card-style Lists */
.todo-item,
.url-item,
.timeline-event {
    background: #252525;
    border: 1px solid #333;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 10px;
    transition: all 0.2s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.todo-item:hover,
.url-item:hover,
.timeline-event:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    border-color: #4a90e2;
}

/* Component Styles */
.todo-input-group {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
}

.url-input-group,
.timeline-input-group {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 15px;
}

.todo-input-group input {
    flex: 1;
    min-width: 0;
}

.url-input-group input[type="text"],
.url-input-group input[type="url"] {
    flex: 1 1 100%;
    min-width: 0;
}

.timeline-input-group input[type="datetime-local"] {
    flex: 1 1 45%;
    min-width: 120px;
}

.timeline-input-group input[type="text"] {
    flex: 1 1 45%;
    min-width: 80px;
}

.todo-input-group input,
.url-input-group input,
.timeline-input-group input {
    background: #1a1a1a;
    border: 1px solid #444;
    padding: 10px 12px;
    border-radius: 6px;
    color: #fff;
    font-size: 0.9rem;
    transition: border-color 0.2s;
}


.timeline-input-group input[type="datetime-local"] {
    font-family: 'Consolas', monospace;
    color-scheme: dark;
}

.todo-input-group input:focus,
.url-input-group input:focus,
.timeline-input-group input:focus {
    border-color: #4a90e2;
    outline: none;
}

.todo-input-group button,
.url-input-group button,
.timeline-input-group button {
    background: #4a90e2;
    color: white;
    border: none;
    width: 38px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 1.2rem;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
    font-weight: normal;
    padding: 0;
}

.todo-input-group button:hover,
.url-input-group button:hover,
.timeline-input-group button:hover {
    background: #357ab8;
    transform: translateY(-1px);
}

/* Specific Item Tweaks */
.todo-item {
    display: flex;
    align-items: center;
    gap: 12px;
}

.todo-item input[type="checkbox"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
    accent-color: #4a90e2;
}

.todo-item-text {
    flex: 1;
    font-size: 0.95rem;
    line-height: 1.4;
    color: #e0e0e0;
}

.todo-item-text.completed {
    color: #666;
    text-decoration: line-through;
}

.todo-item-time {
    font-size: 0.75rem;
    color: #666;
    margin-left: 8px;
    white-space: nowrap;
}

.todo-item-delete,
.url-item-delete,
.timeline-event-delete {
    background: transparent;
    color: #666;
    border: none;
    cursor: pointer;
    font-size: 0.9rem;
    padding: 6px;
    border-radius: 4px;
    transition: all 0.2s;
}

.todo-item-delete:hover,
.url-item-delete:hover,
.timeline-event-delete:hover {
    background: rgba(231, 76, 60, 0.2);
    color: #e74c3c;
}

/* URL Items */
.url-item {
    display: flex;
    align-items: center;
    gap: 12px;
}

.url-item a {
    flex: 1;
    color: #4a90e2;
    text-decoration: none;
    font-size: 0.95rem;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.url-item a:hover {
    text-decoration: underline;
}

/* Timeline specific */
.timeline-event {
    border-left: 3px solid #4a90e2;
    padding-left: 15px;
    padding-right: 35px;
    /* Make room for delete button */
}

/* Remove old dot styles as we are using cards now */
.timeline-event::before {
    display: none;
}

#timelineDisplay {
    padding-left: 0;
}

.timeline-event-date {
    font-family: 'Consolas', monospace;
    font-size: 0.85rem;
    color: #4a90e2;
    margin-bottom: 6px;
    font-weight: bold;
}

.timeline-event-title {
    font-size: 1rem;
    font-weight: 500;
    color: #e0e0e0;
    margin-bottom: 4px;
}

.timeline-event-description {
    font-size: 0.85rem;
    color: #aaa;
    line-height: 1.4;
    margin-top: 4px;
}

.timeline-event-delete {
    position: absolute;
    top: 10px;
    right: 10px;
}

/* Notes Textarea */
#eventNotes {
    width: 100%;
    background: #1a1a1a;
    color: #e0e0e0;
    border: 1px solid #444;
    border-radius: 8px;
    padding: 12px;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-size: 0.95rem;
    resize: vertical;
    outline: none;
    min-height: 100px;
    transition: border-color 0.2s;
}

#eventNotes:focus {
    border-color: #4a90e2;
}

/* Save Button */
#saveEventDataBtn {
    width: 100%;
    background: linear-gradient(135deg, #2ecc71, #27ae60);
    color: white;
    border: none;
    padding: 12px;
    border-radius: 6px;
    font-weight: 600;
    margin-top: 10px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(46, 204, 113, 0.2);
    transition: all 0.2s;
    font-size: 1rem;
}

#saveEventDataBtn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(46, 204, 113, 0.3);
}

.timeline-input-group input[type="text"] {
    flex: 2;
}

.timeline-input-group input[type="datetime-local"] {
    flex: 1.5;
}

/* ==== Event List View Styles ==== */
#eventListView {
    flex: 1;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
}

#eventListContainer {
    flex: 1;
    overflow-y: auto;
    max-height: calc(100vh - 250px);
    padding-right: 5px;
}

.event-card {
    background: #252525;
    border: 1px solid #333;
    border-radius: 8px;
    padding: 12px 15px;
    margin-bottom: 10px;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.event-card:hover {
    border-color: #4a90e2;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

.event-card-info {
    flex: 1;
}

.event-card-date {
    font-size: 0.8rem;
    color: #4a90e2;
    margin-bottom: 4px;
    font-family: 'Consolas', monospace;
}

.event-card-name {
    font-size: 1rem;
    font-weight: 500;
    color: #e0e0e0;
}

.event-card-actions {
    display: flex;
    gap: 8px;
}

.event-card-actions button {
    padding: 6px 12px;
    font-size: 0.8rem;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
}

.btn-edit {
    background: #4a90e2;
    color: white;
}

.btn-edit:hover {
    background: #357ab8;
}

.btn-delete {
    background: transparent;
    color: #e74c3c;
    border: 1px solid #e74c3c !important;
}

.btn-delete:hover {
    background: #e74c3c;
    color: white;
}

.btn-add-event {
    width: 100%;
    padding: 12px;
    margin-top: 15px;
    background: linear-gradient(135deg, #4a90e2, #357ab8);
    color: white;
    border: none;
    border-radius: 6px;
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
}

.btn-add-event:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3);
}

/* Event Edit View */
#eventEditView {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.edit-view-header {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    align-items: center;
}

.btn-back {
    padding: 8px 12px;
    background: transparent;
    border: 1px solid #444;
    color: #aaa;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
    font-size: 0.9rem;
}

.btn-back:hover {
    background: rgba(255, 255, 255, 0.1);
    color: white;
}

#currentEventName {
    flex: 1;
    padding: 10px 12px;
    background: #1a1a1a;
    border: 1px solid #444;
    border-radius: 6px;
    color: #fff;
    font-size: 1rem;
    font-weight: 500;
}

#currentEventName:focus {
    border-color: #4a90e2;
    outline: none;
}

.scrollable-content {
    flex: 1;
    overflow-y: auto;
    padding-right: 5px;
    max-height: calc(100vh - 320px);
}

/* Empty state */
.empty-state {
    text-align: center;
    padding: 40px 20px;
    color: #666;
}

.empty-state i {
    font-size: 3rem;
    margin-bottom: 15px;
    color: #444;
}

.empty-state p {
    font-size: 0.95rem;
}

/* ==== Archive Section Styles ==== */
.archive-section {
    margin-top: 10px;
}

.archive-section h3 {
    font-size: 0.9rem;
    color: #aaa;
    margin-bottom: 10px;
}

.archive-controls {
    display: flex;
    gap: 8px;
    align-items: center;
}

.archive-controls select {
    flex: 1;
    padding: 8px;
    background: #1a1a1a;
    border: 1px solid #444;
    border-radius: 4px;
    color: #fff;
    font-size: 0.85rem;
}

.archive-controls button {
    padding: 8px 12px;
    font-size: 0.85rem;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
}

.archive-controls button:first-of-type {
    background: #4a90e2;
    color: white;
}

.archive-controls button:last-of-type {
    background: #2ecc71;
    color: white;
}

.archive-controls button:hover {
    opacity: 0.85;
    transform: translateY(-1px);
}

.archive-hint {
    font-size: 0.75rem;
    color: #666;
    margin-top: 8px;
    font-style: italic;
}

/* ==== New Archive Management Styles ==== */
.archive-create {
    display: flex;
    gap: 8px;
    margin-bottom: 12px;
}

.archive-create input {
    flex: 1;
    padding: 8px 10px;
    background: #1a1a1a;
    border: 1px solid #444;
    border-radius: 4px;
    color: #fff;
    font-size: 0.85rem;
}

.archive-create button {
    padding: 8px 14px;
    background: #4a90e2;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
}

.archive-create button:hover {
    background: #357ab8;
}

.archive-list {
    max-height: 200px;
    overflow-y: auto;
}

.archive-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 10px;
    background: #252525;
    border-radius: 4px;
    margin-bottom: 6px;
    border: 1px solid #333;
}

.archive-item:hover {
    border-color: #4a90e2;
}

.archive-item-name {
    flex: 1;
    font-size: 0.85rem;
    color: #e0e0e0;
}

.archive-item-date {
    font-size: 0.7rem;
    color: #666;
    margin-right: 10px;
}

.archive-item-actions {
    display: flex;
    gap: 5px;
}

.archive-item-actions button {
    padding: 4px 8px;
    font-size: 0.75rem;
    border: none;
    border-radius: 3px;
    cursor: pointer;
}

.archive-item-actions .load-btn {
    background: #2ecc71;
    color: white;
}

.archive-item-actions .delete-btn {
    background: transparent;
    color: #e74c3c;
    border: 1px solid #e74c3c;
}

.current-archive {
    margin-top: 12px;
    padding: 10px;
    background: rgba(74, 144, 226, 0.15);
    border: 1px solid #4a90e2;
    border-radius: 4px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.current-archive span {
    font-size: 0.85rem;
    color: #4a90e2;
}

.current-archive button {
    padding: 6px 12px;
    background: #4a90e2;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

/* ==== Attachment Styles ==== */
.attachment-upload {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}

.attachment-upload input[type="file"] {
    display: none;
}

.upload-btn {
    padding: 8px 14px;
    background: #4a90e2;
    color: white;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.85rem;
    transition: all 0.2s;
}

.upload-btn:hover {
    background: #357ab8;
}

.upload-hint {
    font-size: 0.75rem;
    color: #666;
}

.attachment-list {
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.attachment-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 10px;
    background: #252525;
    border-radius: 4px;
    border: 1px solid #333;
}

.attachment-item-info {
    display: flex;
    align-items: center;
    gap: 8px;
    flex: 1;
}

.attachment-item-icon {
    font-size: 1.2rem;
}

.attachment-item-name {
    font-size: 0.85rem;
    color: #e0e0e0;
}

.attachment-item-size {
    font-size: 0.7rem;
    color: #666;
}

.attachment-item-actions {
    display: flex;
    gap: 5px;
}

.attachment-item-actions button {
    padding: 4px 8px;
    font-size: 0.75rem;
    border: none;
    border-radius: 3px;
    cursor: pointer;
    background: #4a90e2;
    color: white;
}

.attachment-item-actions .delete-btn {
    background: transparent;
    color: #e74c3c;
    border: 1px solid #e74c3c;
}
</style>
</head>

<body>
    <!-- å·¦ä¾§æ§åˆ¶é¢æ¿ -->
    <div id="controls" class="panel">
        <h2>åœ°å›¾æ§åˆ¶</h2>

        <!-- åŸºç¡€åŠŸèƒ½ -->
        <div class="control-group">
            <label for="baseMapSelect">åº•å›¾é€‰æ‹©ï¼š</label>
            <select id="baseMapSelect">
                <option value="osm">OpenStreetMap</option>
                <option value="stamen">Stamen Toner</option>
                <option value="carto">CartoDB Positron</option>
            </select>
        </div>

        <hr class="divider">

        <!-- GeoJSON åŠŸèƒ½ -->
        <div class="control-group">
            <button id="exportGeoJSONBtn">å¯¼å‡º GeoJSON</button>
        </div>
        <div class="control-group">
            <label for="geojsonFile">å¯¼å…¥ GeoJSONï¼š</label>
            <input type="file" id="geojsonFile" accept=".json,.geojson" />
        </div>
        <div class="control-group">
            <button id="toggleEditorBtn">æ˜¾ç¤ºä»£ç ç¼–è¾‘å™¨</button>
        </div>

        <hr class="divider">

        <!-- å›¾å±‚é¢æ¿æ§åˆ¶ -->
        <div class="control-group">
            <button id="toggleLayerPanelBtn">æ˜¾ç¤ºå›¾å±‚é¢æ¿</button>
        </div>

        <hr class="divider">

        <!-- Excel/CSV æ•°æ®å¯¼å…¥å¯¼å‡º -->
        <div class="control-group">
            <label>ä¸‹è½½å¯¼å…¥æ¨¡æ¿ï¼š</label>
            <button id="downloadTemplateBtn">ä¸‹è½½ Excel æ¨¡æ¿</button>
        </div>
        <div class="control-group">
            <label for="excelFile">å¯¼å…¥ Excelï¼š</label>
            <input type="file" id="excelFile" accept=".xlsx,.xls" />
        </div>
        <div class="control-group">
            <button id="exportExcelBtn">å¯¼å‡º Excelï¼ˆå®Œæ•´å­—æ®µï¼‰</button>
        </div>
        <div class="control-group">
            <label for="coordFile">å¯¼å…¥ CSVï¼š</label>
            <input type="file" id="coordFile" accept=".csv,.txt" />
        </div>
        <div class="control-group">
            <button id="exportBtn">å¯¼å‡º CSVï¼ˆä»…åæ ‡ï¼‰</button>
        </div>

        <hr class="divider">

        <!-- å·¥å…·åŠŸèƒ½ -->
        <div class="control-group">
            <button id="togglePickerBtn">å¯ç”¨åæ ‡æ‹¾å–</button>
            <div id="pickedCoords" style="font-size:0.8rem; color:#aaa; margin-top:4px;"></div>
        </div>
        <div class="control-group">
            <label>æ‰‹åŠ¨æ·»åŠ æ ‡æ³¨ï¼š</label>
            <input type="text" id="manualNote" placeholder="è¾“å…¥å¤‡æ³¨ä¿¡æ¯" />
            <button id="addManualMarkerBtn">ç‚¹å‡»åœ°å›¾æ·»åŠ </button>
        </div>
        <div class="control-group">
            <label for="searchAddress">æœç´¢åœ°å€ï¼š</label>
            <input type="text" id="searchAddress" placeholder="è¾“å…¥åœ°å€æœç´¢" />
            <button id="searchBtn">æœç´¢</button>
        </div>
        <div class="control-group">
            <label>è¾“å…¥åæ ‡å®šä½ï¼š</label>
            <input type="number" id="gotoLat" placeholder="çº¬åº¦" step="0.000001" style="width:100%; margin-bottom:4px;" />
            <input type="number" id="gotoLng" placeholder="ç»åº¦" step="0.000001" style="width:100%; margin-bottom:4px;" />
            <button id="gotoCoordBtn">è·³è½¬åˆ°ä¸­å¿ƒ</button>
        </div>

        <hr class="divider">

        <!-- æ˜¾ç¤ºé€‰é¡¹ -->
        <div class="control-group">
            <label for="markerIconSelect">æ ‡è®°å›¾æ ‡æ ·å¼ï¼š</label>
            <select id="markerIconSelect">
                <option value="blue">è“è‰²æ ‡è®°</option>
                <option value="red">çº¢è‰²æ ‡è®°</option>
                <option value="green">ç»¿è‰²æ ‡è®°</option>
                <option value="orange">æ©™è‰²æ ‡è®°</option>
                <option value="yellow">é»„è‰²æ ‡è®°</option>
                <option value="violet">ç´«è‰²æ ‡è®°</option>
                <option value="grey">ç°è‰²æ ‡è®°</option>
                <option value="black">é»‘è‰²æ ‡è®°</option>
            </select>
        </div>
        <div class="control-group">
            <label>
                <input type="checkbox" id="showLabelsCheck" />
                æ˜¾ç¤ºæ ‡æ³¨åç§°
            </label>
        </div>
    </div>

    <!-- å³ä¾§å›¾å±‚é¢æ¿ -->
    <div id="layerPanel" class="panel">
        <h2>å›¾å±‚åˆ—è¡¨</h2>
        <div id="layerList"></div>
        <button id="clearAllBtn" style="margin-top:10px; width:100%; background:#e74c3c;">æ¸…ç©ºæ‰€æœ‰å›¾å±‚</button>

        <hr class="divider">

        <!-- å­˜æ¡£ç®¡ç† -->
        <div class="archive-section">
            <h3>ğŸ’¾ å­˜æ¡£ç®¡ç†</h3>
            <div class="archive-create">
                <input type="text" id="newArchiveName" placeholder="è¾“å…¥å­˜æ¡£åç§°..." />
                <button onclick="createArchive()">æ–°å»º</button>
            </div>
            <div id="archiveList" class="archive-list"></div>
            <div id="currentArchiveInfo" class="current-archive" style="display:none;">
                <span>å½“å‰: <strong id="currentArchiveName"></strong></span>
                <button onclick="saveCurrentArchive()">ä¿å­˜</button>
            </div>
        </div>
    </div>


    <!-- æˆ˜ç•¥äº‹ä»¶è¿½è¸ªå™¨é¢æ¿ -->
    <div id="eventTrackerPanel" class="panel" style="display:none;">
        <div class="panel-header">
            <h2>æˆ˜ç•¥äº‹ä»¶è¿½è¸ªå™¨</h2>
            <button id="closeEventTrackerBtn" onclick="closeEventTracker()">å…³é—­</button>
        </div>

        <p id="eventTrackerFeatureName" style="font-weight:600; margin-bottom:10px; color:#4a90e2;"></p>

        <!-- äº‹ä»¶åˆ—è¡¨è§†å›¾ -->
        <div id="eventListView">
            <div id="eventListContainer"></div>
            <button class="btn-add-event" onclick="createNewEvent()">+ æ–°å¢äº‹ä»¶</button>
        </div>

        <!-- äº‹ä»¶ç¼–è¾‘è§†å›¾ -->
        <div id="eventEditView" style="display:none;">
            <div class="edit-view-header">
                <button class="btn-back" onclick="showEventList()">â—€ è¿”å›åˆ—è¡¨</button>
                <input type="text" id="currentEventName" placeholder="äº‹ä»¶åç§°" />
            </div>

            <div id="eventTrackerContent" class="scrollable-content">
                <!-- Todo List Section -->
                <div class="tracker-section">
                    <h3>ä»»åŠ¡æ¸…å•</h3>
                    <div class="todo-input-group">
                        <input type="text" id="newTodoInput" placeholder="æ·»åŠ æ–°ä»»åŠ¡..." />
                        <button id="addTodoBtn" onclick="addTodoItemClick()">+</button>
                    </div>
                    <div id="todoList"></div>
                </div>

                <!-- Notes Section -->
                <div class="tracker-section">
                    <h3>å¤‡æ³¨è¯´æ˜</h3>
                    <textarea id="eventNotes" placeholder="è¾“å…¥æ–‡æœ¬æè¿°..." rows="4"></textarea>
                </div>

                <!-- URL Links Section -->
                <div class="tracker-section">
                    <h3>ç›¸å…³é“¾æ¥</h3>
                    <div class="url-input-group">
                        <input type="text" id="urlTitle" placeholder="é“¾æ¥æ ‡é¢˜" />
                        <input type="url" id="urlAddress" placeholder="URLåœ°å€" />
                        <button id="addUrlBtn" onclick="addUrlItemClick()">+</button>
                    </div>
                    <div id="urlList"></div>
                </div>

                <!-- Timeline Section -->
                <div class="tracker-section">
                    <h3>æ—¶é—´è½´</h3>
                    <div class="timeline-input-group">
                        <input type="datetime-local" id="timelineDate" step="60" />
                        <input type="text" id="timelineTitle" placeholder="äº‹ä»¶æ ‡é¢˜" />
                        <button id="addTimelineBtn" onclick="addTimelineEventClick()">+</button>
                    </div>
                    <div id="timelineDisplay"></div>
                </div>

                <!-- Attachments Section -->
                <div class="tracker-section">
                    <h3>ğŸ“ é™„ä»¶</h3>
                    <div class="attachment-upload">
                        <input type="file" id="attachmentInput" onchange="uploadAttachment()" />
                        <label for="attachmentInput" class="upload-btn">é€‰æ‹©æ–‡ä»¶</label>
                        <span class="upload-hint">æ”¯æŒå›¾ç‰‡ã€PDFç­‰ (æœ€å¤§500KB)</span>
                    </div>
                    <div id="attachmentList" class="attachment-list"></div>
                </div>
            </div>


            <!-- Save Button -->
            <button id="saveEventDataBtn" onclick="saveCurrentEvent()">ä¿å­˜äº‹ä»¶</button>
        </div>
    </div>


    <!--åœ°å›¾å®¹å™¨ -->
    <div id="map"></div>

    <!-- å³é”®èœå• -->
    <div id="contextMenu" class="context-menu" style="display:none;">
        <div class="context-menu-item" onclick="openEventTrackerFromMenu()">ğŸ“‹ äº‹ä»¶è¿½è¸ªå™¨</div>
        <div class="context-menu-item" onclick="editMarkerProperties()">ç¼–è¾‘å±æ€§</div>
        <div class="context-menu-item" onclick="changeMarkerIcon()">æ›´æ”¹å›¾æ ‡</div>
        <div class="context-menu-item" onclick="deleteSelectedMarker()">åˆ é™¤æ ‡è®°</div>
    </div>

    <!-- GeoJSON ä»£ç ç¼–è¾‘å™¨ï¼ˆé»˜è®¤éšè—ï¼‰ -->
    <div id="editorPanel" style="display:none;">
        <h2>GeoJSON ç¼–è¾‘å™¨</h2>

        <!-- Code Archive Management -->
        <div class="archive-section" style="margin-bottom:10px;">
            <div class="archive-create">
                <input type="text" id="newCodeArchiveName" placeholder="è¾“å…¥ä»£ç å­˜æ¡£åç§°..." />
                <button onclick="createCodeArchive()">æ–°å»º</button>
            </div>
            <div id="codeArchiveList" class="archive-list" style="max-height:120px;"></div>
            <div id="currentCodeArchiveInfo" class="current-archive" style="display:none;">
                <span>å½“å‰: <strong id="currentCodeArchiveName"></strong></span>
                <button onclick="saveCurrentCodeArchive()">ä¿å­˜</button>
            </div>
        </div>


        <textarea id="geojsonEditor" spellcheck="false"></textarea>

        <div style="display:flex; gap:10px;">
            <button id="applyEditorBtn" style="flex:1;">åº”ç”¨åˆ°åœ°å›¾</button>
            <button
                onclick="document.getElementById('editorPanel').style.display='none'; document.getElementById('toggleEditorBtn').textContent='æ˜¾ç¤ºä»£ç ç¼–è¾‘å™¨'"
                style="flex:1; background:#e74c3c;">å…³é—­</button>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <!-- Leaflet.draw JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js" crossorigin=""></script>
    <!-- PapaParse for CSV parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"
        crossorigin="anonymous"></script>
    <!-- SheetJS for Excel support -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script>
// script.js - GeoJSON Map Editor with FontAwesome marker icons

// ==== Configuration ==== //
const AMAP_API_KEY = 'f9ef1f8a897389df48a43e18ac4660d8';
const AMAP_GEOCODE_URL = 'https://restapi.amap.com/v3/geocode/geo';

// ==== Initialize Map ==== //
const map = L.map('map').setView([36.0671, 120.3826], 12); // é’å²›å¸‚ä¸­å¿ƒ

// Base layers
const baseLayers = {
    osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors',
        maxZoom: 19,
    }),
    stamen: L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/toner/{z}/{x}/{y}.png', {
        attribution: '&copy; Stamen Design',
        maxZoom: 20,
    }),
    carto: L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; CartoDB',
        maxZoom: 19,
    }),
};
baseLayers.osm.addTo(map);

// ==== FontAwesome Icon Marker System ==== //
// Map marker-symbol values to FontAwesome icon classes
const iconClassMap = {
    'car': 'fa-solid fa-car',
    'vehicle': 'fa-solid fa-car',
    'shop': 'fa-solid fa-bag-shopping',
    'store': 'fa-solid fa-bag-shopping',
    'fuel': 'fa-solid fa-gas-pump',
    'gas_station': 'fa-solid fa-gas-pump',
    'warehouse': 'fa-solid fa-warehouse',
    'building': 'fa-solid fa-warehouse',
    'default': 'fa-solid fa-location-dot'
};

// Create custom marker icon with FontAwesome
function createCustomMarkerIcon(color, symbol) {
    // Default to blue if color not provided or invalid
    if (!color || color.indexOf('#') !== 0) {
        color = '#4a90e2'; // default blue
    }

    // Get FontAwesome icon class
    const iconClass = iconClassMap[symbol] || iconClassMap['default'];

    // Create HTML with circular background and FontAwesome icon
    // Create HTML with circular background and FontAwesome icon
    const html = `
        <div class="custom-marker-wrapper">
            <div class="custom-marker-circle" style="background-color: ${color};">
                <i class="${iconClass}"></i>
            </div>
            <div class="custom-marker-tip" style="border-top-color: ${color};"></div>
        </div>
    `;

    return L.divIcon({
        html: html,
        className: 'custom-marker-icon',
        iconSize: [30, 42],
        iconAnchor: [15, 42],
        popupAnchor: [0, -42]
    });
}

// Determine icon based on feature properties
function getMarkerIcon(properties) {
    let color = '#4a90e2'; // default blue
    let symbol = 'default';

    if (properties) {
        // Read marker-color (hex color like #00AA00)
        if (properties['marker-color']) {
            color = properties['marker-color'];
            // If it's a named color, convert to hex
            if (color.indexOf('#') !== 0) {
                const colorMap = {
                    'blue': '#4a90e2',
                    'red': '#e74c3c',
                    'green': '#2ecc71',
                    'orange': '#f39c12',
                    'yellow': '#f1c40f',
                    'violet': '#9b59b6',
                    'purple': '#800080',
                    'grey': '#95a5a6',
                    'black': '#2c3e50'
                };
                color = colorMap[color.toLowerCase()] || '#4a90e2';
            }
        }

        // Read marker-symbol or type
        if (properties['marker-symbol']) {
            symbol = properties['marker-symbol'];
        } else if (properties.type) {
            const type = properties.type.toLowerCase();
            const symbolMap = {
                'shop': 'shop',
                'store': 'shop',
                'å•†åº—': 'shop',
                'å¿«å‡†æœåŠ¡ç«™': 'shop',
                'warehouse': 'warehouse',
                'building': 'warehouse',
                'ä»“åº“': 'warehouse',
                'æ–°åº·ä¼—æœåŠ¡ç«™': 'warehouse',
                'fuel': 'fuel',
                'gas_station': 'fuel',
                'åŠ æ²¹ç«™': 'fuel',
                'æ±½æœé—¨åº—': 'fuel',
                'car': 'car',
                'vehicle': 'car',
                'æ±½è½¦': 'car',
                'ä¼˜é…æœåŠ¡ç«™': 'car'
            };

            if (symbolMap[type]) {
                symbol = symbolMap[type];
            } else {
                // Substring match
                for (const key in symbolMap) {
                    if (type.includes(key)) {
                        symbol = symbolMap[key];
                        break;
                    }
                }
            }
        }
    }

    return createCustomMarkerIcon(color, symbol);
}

// ==== Leaflet.draw Setup ==== //
const drawnItems = new L.FeatureGroup();
map.addLayer(drawnItems);

L.drawLocal = {
    draw: {
        toolbar: {
            actions: { title: 'å–æ¶ˆç»˜åˆ¶', text: 'å–æ¶ˆ' },
            finish: { title: 'å®Œæˆç»˜åˆ¶', text: 'å®Œæˆ' },
            undo: { title: 'åˆ é™¤æœ€åä¸€ä¸ªç‚¹', text: 'åˆ é™¤æœ€åä¸€ä¸ªç‚¹' },
            buttons: {
                polyline: 'ç»˜åˆ¶æŠ˜çº¿',
                polygon: 'ç»˜åˆ¶å¤šè¾¹å½¢',
                rectangle: 'ç»˜åˆ¶çŸ©å½¢',
                circle: 'ç»˜åˆ¶åœ†å½¢',
                marker: 'æ·»åŠ æ ‡è®°',
                circlemarker: 'æ·»åŠ åœ†å½¢æ ‡è®°'
            }
        },
        handlers: {
            circle: { tooltip: { start: 'ç‚¹å‡»å¹¶æ‹–åŠ¨ç»˜åˆ¶åœ†å½¢' }, radius: 'åŠå¾„' },
            circlemarker: { tooltip: { start: 'ç‚¹å‡»åœ°å›¾æ”¾ç½®åœ†å½¢æ ‡è®°' } },
            marker: { tooltip: { start: 'ç‚¹å‡»åœ°å›¾æ”¾ç½®æ ‡è®°' } },
            polygon: { tooltip: { start: 'ç‚¹å‡»å¼€å§‹ç»˜åˆ¶å¤šè¾¹å½¢', cont: 'ç‚¹å‡»ç»§ç»­ç»˜åˆ¶å¤šè¾¹å½¢', end: 'ç‚¹å‡»ç¬¬ä¸€ä¸ªç‚¹å®Œæˆå¤šè¾¹å½¢' } },
            polyline: { error: '<strong>é”™è¯¯:</strong> çº¿æ®µä¸èƒ½äº¤å‰!', tooltip: { start: 'ç‚¹å‡»å¼€å§‹ç»˜åˆ¶æŠ˜çº¿', cont: 'ç‚¹å‡»ç»§ç»­ç»˜åˆ¶æŠ˜çº¿', end: 'ç‚¹å‡»æœ€åä¸€ä¸ªç‚¹å®ŒæˆæŠ˜çº¿' } },
            rectangle: { tooltip: { start: 'ç‚¹å‡»å¹¶æ‹–åŠ¨ç»˜åˆ¶çŸ©å½¢' } },
            simpleshape: { tooltip: { end: 'é‡Šæ”¾é¼ æ ‡å®Œæˆç»˜åˆ¶' } }
        }
    },
    edit: {
        toolbar: {
            actions: { save: { title: 'ä¿å­˜æ›´æ”¹', text: 'ä¿å­˜' }, cancel: { title: 'å–æ¶ˆç¼–è¾‘ï¼Œæ”¾å¼ƒæ‰€æœ‰æ›´æ”¹', text: 'å–æ¶ˆ' }, clearAll: { title: 'æ¸…é™¤æ‰€æœ‰å›¾å±‚', text: 'å…¨éƒ¨æ¸…é™¤' } },
            buttons: { edit: 'ç¼–è¾‘å›¾å±‚', editDisabled: 'æ²¡æœ‰å¯ç¼–è¾‘çš„å›¾å±‚', remove: 'åˆ é™¤å›¾å±‚', removeDisabled: 'æ²¡æœ‰å¯åˆ é™¤çš„å›¾å±‚' }
        },
        handlers: { edit: { tooltip: { text: 'æ‹–åŠ¨æ§åˆ¶ç‚¹æˆ–æ ‡è®°æ¥ç¼–è¾‘è¦ç´ ', subtext: 'ç‚¹å‡»å–æ¶ˆæ’¤é”€æ›´æ”¹' } }, remove: { tooltip: { text: 'ç‚¹å‡»è¦åˆ é™¤çš„è¦ç´ ' } } }
    }
};

const drawControl = new L.Control.Draw({
    position: 'topleft',
    draw: {
        polyline: { shapeOptions: { color: '#00ff00', weight: 3 } },
        polygon: { allowIntersection: false, shapeOptions: { color: '#ff7800', fillOpacity: 0.3 } },
        rectangle: { shapeOptions: { color: '#ff7800', fillOpacity: 0.3 } },
        circle: { shapeOptions: { color: '#ff7800', fillOpacity: 0.2 } },
        marker: true,
        circlemarker: false
    },
    edit: { featureGroup: drawnItems, remove: true }
});
map.addControl(drawControl);

// ==== UI Elements ==== //
const baseMapSelect = document.getElementById('baseMapSelect');
const exportGeoJSONBtn = document.getElementById('exportGeoJSONBtn');
const geojsonFileInput = document.getElementById('geojsonFile');
const toggleEditorBtn = document.getElementById('toggleEditorBtn');
const editorPanel = document.getElementById('editorPanel');
const geojsonEditor = document.getElementById('geojsonEditor');
const applyEditorBtn = document.getElementById('applyEditorBtn');
const layerList = document.getElementById('layerList');
const clearAllBtn = document.getElementById('clearAllBtn');
const showLabelsCheck = document.getElementById('showLabelsCheck');
const markerIconSelect = document.getElementById('markerIconSelect');

// Save slot controls
const saveSlotSelect = document.getElementById('saveSlotSelect');
const saveSlotBtn = document.getElementById('saveSlotBtn');
const loadSlotBtn = document.getElementById('loadSlotBtn');

// Legacy UI elements
const addressFileInput = document.getElementById('addressFile');
const exportBtn = document.getElementById('exportBtn');
const coordFileInput = document.getElementById('coordFile');
const togglePickerBtn = document.getElementById('togglePickerBtn');
const pickedCoordsDiv = document.getElementById('pickedCoords');
const manualNoteInput = document.getElementById('manualNote');
const addManualMarkerBtn = document.getElementById('addManualMarkerBtn');
const searchAddressInput = document.getElementById('searchAddress');
const searchBtn = document.getElementById('searchBtn');
const gotoLatInput = document.getElementById('gotoLat');
const gotoLngInput = document.getElementById('gotoLng');
const gotoCoordBtn = document.getElementById('gotoCoordBtn');
const toggleLayerPanelBtn = document.getElementById('toggleLayerPanelBtn');

// Excel UI elements
const downloadTemplateBtn = document.getElementById('downloadTemplateBtn');
const excelFileInput = document.getElementById('excelFile');
const exportExcelBtn = document.getElementById('exportExcelBtn');

// Event Tracker UI elements
const eventTrackerPanel = document.getElementById('eventTrackerPanel');
const closeEventTrackerBtn = document.getElementById('closeEventTrackerBtn');
const eventTrackerFeatureName = document.getElementById('eventTrackerFeatureName');
const newTodoInput = document.getElementById('newTodoInput');
const addTodoBtn = document.getElementById('addTodoBtn');
const todoList = document.getElementById('todoList');
const eventNotes = document.getElementById('eventNotes');
const urlTitle = document.getElementById('urlTitle');
const urlAddress = document.getElementById('urlAddress');
const addUrlBtn = document.getElementById('addUrlBtn');
const urlList = document.getElementById('urlList');
const timelineDate = document.getElementById('timelineDate');
const timelineTitle = document.getElementById('timelineTitle');
const addTimelineBtn = document.getElementById('addTimelineBtn');
const timelineDisplay = document.getElementById('timelineDisplay');
const saveEventDataBtn = document.getElementById('saveEventDataBtn');

// ==== State Variables ==== //
let pickerMode = false;
let manualMarkerMode = false;
let layerCounter = 0;
let showLabels = false;
let currentMarkerColor = 'blue';
let contextMenuTarget = null;
let currentTrackedFeature = null; // Feature currently being tracked in event panel
let currentEditingEventId = null; // Currently editing event ID
let eventIdCounter = Date.now(); // Unique ID counter for events


// ==== Independent Event Storage System ==== //
const EVENTS_STORAGE_KEY = 'map_events_data';

// Generate unique event ID
function generateEventId() {
    return `evt_${eventIdCounter++}_${Math.random().toString(36).substr(2, 9)}`;
}

// Get all events from localStorage
function getAllEvents() {
    try {
        const data = localStorage.getItem(EVENTS_STORAGE_KEY);
        return data ? JSON.parse(data) : {};
    } catch (e) {
        console.error('Failed to load events:', e);
        return {};
    }
}

// Save all events to localStorage
function saveAllEvents(events) {
    try {
        localStorage.setItem(EVENTS_STORAGE_KEY, JSON.stringify(events));
        console.log('Events saved:', Object.keys(events).length);
    } catch (e) {
        console.error('Failed to save events:', e);
    }
}

// Get event data for a specific feature
function getEventData(eventId) {
    const events = getAllEvents();
    return events[eventId] || null;
}

// Set event data for a specific feature
function setEventData(eventId, data) {
    const events = getAllEvents();
    events[eventId] = data;
    saveAllEvents(events);
}

// Delete event data for a specific feature
function deleteEventData(eventId) {
    const events = getAllEvents();
    if (events[eventId]) {
        delete events[eventId];
        saveAllEvents(events);
    }
}

// Initialize event data structure
function initEventData() {
    return {
        todos: [],
        notes: '',
        urls: [],
        timeline: []
    };
}


// ==== Save Slot Management (Legacy - kept for compatibility) ==== //
function updateSlotOptions() {
    if (!saveSlotSelect) return; // Element removed, skip

    const slots = ['slot1', 'slot2', 'slot3', 'slot4', 'slot5'];
    slots.forEach((slotId, index) => {
        const meta = localStorage.getItem(`geojson_${slotId}_meta`);
        const option = saveSlotSelect.options[index];
        if (!option) return;

        if (meta) {
            try {
                const { timestamp } = JSON.parse(meta);
                const date = new Date(timestamp);
                const dateStr = `${date.getMonth() + 1}-${date.getDate()} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
                option.text = `å­˜æ¡£ ${index + 1} (${dateStr})`;
            } catch (e) {
                option.text = `å­˜æ¡£ ${index + 1} (å·²ä¿å­˜)`;
            }
        } else {
            option.text = `å­˜æ¡£ ${index + 1} (ç©º)`;
        }
    });
}

// Initialize slot options on page load
updateSlotOptions();


// ==== Helper Functions ==== //
function updateLayerList() {
    layerList.innerHTML = '';
    let index = 0;
    drawnItems.eachLayer(layer => {
        const item = document.createElement('div');
        item.className = 'layer-item';
        const type = layer instanceof L.Marker ? 'æ ‡è®°' :
            layer instanceof L.Circle ? 'åœ†å½¢' :
                layer instanceof L.Rectangle ? 'çŸ©å½¢' :
                    layer instanceof L.Polygon ? 'å¤šè¾¹å½¢' :
                        layer instanceof L.Polyline ? 'æŠ˜çº¿' : 'å›¾å±‚';
        const name = layer.options.name || `${type} ${index + 1} `;
        item.innerHTML = `
        < div class="layer-item-header" >
                <span class="layer-name">${name}</span>
                <span class="layer-type">${type}</span>
            </div >
        <div class="layer-actions">
            <button class="layer-btn" onclick="toggleLayerVisibility(${layer._leaflet_id})">éšè—</button>
            <button class="layer-btn" onclick="renameLayer(${layer._leaflet_id})">é‡å‘½å</button>
            <button class="layer-btn delete" onclick="deleteLayer(${layer._leaflet_id})">åˆ é™¤</button>
        </div>
    `;
        layerList.appendChild(item);
        index++;
    });
    updateGeoJSONEditor();
}

function updateGeoJSONEditor() {
    const geo = drawnItems.toGeoJSON();
    geojsonEditor.value = JSON.stringify(geo, null, 2);
}

function exportGeoJSON() {
    const data = JSON.stringify(drawnItems.toGeoJSON(), null, 2);
    const uri = 'data:application/json;charset=utf-8,' + encodeURIComponent(data);
    const a = document.createElement('a');
    a.setAttribute('href', uri);
    a.setAttribute('download', 'map.geojson');
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

function importGeoJSON(raw) {
    try {
        const geo = typeof raw === 'string' ? JSON.parse(raw) : raw;
        L.geoJSON(geo, {
            pointToLayer: (feature, latlng) => {
                const icon = getMarkerIcon(feature.properties);
                const marker = L.marker(latlng, { icon });
                marker.feature = { properties: feature.properties || {} };
                bindMarkerContextMenu(marker);
                return marker;
            },
            style: feature => {
                const style = {};
                if (feature.properties) {
                    if (feature.properties.stroke) style.color = feature.properties.stroke;
                    if (feature.properties['stroke-width']) style.weight = feature.properties['stroke-width'];
                    if (feature.properties['stroke-opacity']) style.opacity = feature.properties['stroke-opacity'];
                    if (feature.properties.fill) style.fillColor = feature.properties.fill;
                    if (feature.properties['fill-opacity']) style.fillOpacity = feature.properties['fill-opacity'];
                    if (feature.properties.dashArray || feature.properties.style === 'dashed') style.dashArray = '10,10';
                }
                return style;
            },
            onEachFeature: (feature, layer) => {
                if (feature.properties && feature.properties.name) {
                    layer.options.name = feature.properties.name;
                }
                if (layer instanceof L.Circle && feature.properties) {
                    if (feature.properties.dashArray || feature.properties.style === 'dashed') {
                        layer.setStyle({ dashArray: '10,10', weight: 2 });
                    }
                }
                // Bind popup for point markers
                if (layer instanceof L.Marker) {
                    const latlng = layer.getLatLng();
                    const name = feature.properties?.name || '';
                    const type = feature.properties?.type || '';
                    const address = feature.properties?.address || '';
                    const popupHtml = `<h3>${name}</h3>` +
                        `<p>ç±»å‹: ${type}<br>åœ°å€: ${address}<br>` +
                        `ç»çº¬åº¦: ${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)} ` +
                        `<button onclick="navigator.clipboard.writeText('${latlng.lat},${latlng.lng}')">å¤åˆ¶</button></p>`;
                    layer.bindPopup(popupHtml);
                }
                drawnItems.addLayer(layer);
                if (layer instanceof L.Marker) bindMarkerContextMenu(layer);
            }
        });
        updateLayerList();
        if (drawnItems.getLayers().length) map.fitBounds(drawnItems.getBounds());
    } catch (e) {
        alert('GeoJSON è§£æé”™è¯¯ï¼š' + e.message);
    }
}

function updateLabels() {
    drawnItems.eachLayer(layer => {
        if (layer.getTooltip()) layer.unbindTooltip();
        if (showLabels && layer.options.name) {
            layer.bindTooltip(layer.options.name, { permanent: true, direction: 'center', className: 'layer-label' });
        }
    });
}

// ==== Context Menu Functions ==== //
function bindMarkerContextMenu(marker) {
    marker.on('contextmenu', e => {
        contextMenuTarget = marker;
        const menu = document.getElementById('contextMenu');
        menu.style.left = e.originalEvent.pageX + 'px';
        menu.style.top = e.originalEvent.pageY + 'px';
        menu.style.display = 'block';
    });
}

function hideContextMenu() {
    const menu = document.getElementById('contextMenu');
    menu.style.display = 'none';
    contextMenuTarget = null;
}

function editMarkerProperties() {
    if (!contextMenuTarget) return;
    const newName = prompt('è¾“å…¥æ–°åç§°ï¼š', contextMenuTarget.options.name || '');
    if (newName !== null) {
        contextMenuTarget.options.name = newName;
        if (!contextMenuTarget.feature) contextMenuTarget.feature = { properties: {} };
        contextMenuTarget.feature.properties.name = newName;
        updateLayerList();
        updateLabels();
    }
    hideContextMenu();
}

function changeMarkerIcon() {
    if (!contextMenuTarget) return;
    const color = prompt('è¾“å…¥é¢œè‰²ä»£ç  (ä¾‹å¦‚ #00AA00)ï¼š', contextMenuTarget.feature?.properties?.['marker-color'] || '#4a90e2');
    if (color) {
        const icon = createCustomMarkerIcon(color, contextMenuTarget.feature?.properties?.['marker-symbol'] || 'default');
        contextMenuTarget.setIcon(icon);
        if (!contextMenuTarget.feature) contextMenuTarget.feature = { properties: {} };
        contextMenuTarget.feature.properties['marker-color'] = color;
    }
    hideContextMenu();
}

function deleteSelectedMarker() {
    if (!contextMenuTarget) return;
    drawnItems.removeLayer(contextMenuTarget);
    updateLayerList();
    hideContextMenu();
}

function openEventTrackerFromMenu() {
    if (!contextMenuTarget) return;
    openEventTracker(contextMenuTarget);
    hideContextMenu();
}

map.on('click', () => hideContextMenu());

// ==== Event Listeners ==== //
baseMapSelect.addEventListener('change', () => {
    const sel = baseMapSelect.value;
    Object.values(baseLayers).forEach(l => map.removeLayer(l));
    baseLayers[sel].addTo(map);
});

map.on(L.Draw.Event.CREATED, e => {
    const layer = e.layer;
    layer.options.name = `å›¾å±‚ ${++layerCounter} `;
    if (layer instanceof L.Marker) {
        const icon = createCustomMarkerIcon('#4a90e2', 'default');
        layer.setIcon(icon);
        layer.feature = { properties: { 'marker-color': '#4a90e2' } };
        bindMarkerContextMenu(layer);
    }
    drawnItems.addLayer(layer);
    updateLayerList();
    updateLabels();
});

map.on(L.Draw.Event.EDITED, () => updateLayerList());
map.on(L.Draw.Event.DELETED, () => updateLayerList());

exportGeoJSONBtn.addEventListener('click', exportGeoJSON);
geojsonFileInput.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = ev => importGeoJSON(ev.target.result);
    reader.readAsText(file);
});

toggleEditorBtn.addEventListener('click', () => {
    if (editorPanel.style.display === 'none') {
        editorPanel.style.display = 'flex';
        toggleEditorBtn.textContent = 'éšè—ä»£ç ç¼–è¾‘å™¨';
        updateGeoJSONEditor();
    } else {
        editorPanel.style.display = 'none';
        toggleEditorBtn.textContent = 'æ˜¾ç¤ºä»£ç ç¼–è¾‘å™¨';
    }
});

applyEditorBtn.addEventListener('click', () => {
    drawnItems.clearLayers();
    importGeoJSON(geojsonEditor.value);
});

clearAllBtn.addEventListener('click', () => {
    if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å›¾å±‚å—ï¼Ÿ')) {
        drawnItems.clearLayers();
        updateLayerList();
    }
});

showLabelsCheck.addEventListener('change', e => {
    showLabels = e.target.checked;
    updateLabels();
});

markerIconSelect.addEventListener('change', e => {
    currentMarkerColor = e.target.value;
});

// Save Slot Event Listeners (Legacy - elements may be removed)
if (saveSlotBtn && saveSlotSelect) {
    saveSlotBtn.addEventListener('click', () => {
        const slot = saveSlotSelect.value;
        const content = geojsonEditor.value;
        const meta = {
            timestamp: Date.now(),
            size: content.length
        };
        localStorage.setItem(`geojson_${slot}`, content);
        localStorage.setItem(`geojson_${slot}_meta`, JSON.stringify(meta));
        updateSlotOptions();
        console.log('å·²ä¿å­˜åˆ°å­˜æ¡£');
    });
}

if (loadSlotBtn && saveSlotSelect) {
    loadSlotBtn.addEventListener('click', () => {
        const slot = saveSlotSelect.value;
        const content = localStorage.getItem(`geojson_${slot}`);
        if (content) {
            geojsonEditor.value = content;
        } else {
            console.log('å­˜æ¡£ä¸ºç©º');
        }
    });
}


// ---- Legacy Features ---- //
exportBtn.addEventListener('click', () => {
    const rows = [];
    drawnItems.eachLayer(l => {
        if (l instanceof L.Marker) {
            const ll = l.getLatLng();
            rows.push(`${ll.lat},${ll.lng} `);
        }
    });
    const csv = 'data:text/csv;charset=utf-8,latitude,longitude\n' + rows.join('\n');
    const a = document.createElement('a');
    a.setAttribute('href', encodeURI(csv));
    a.setAttribute('download', 'coordinates.csv');
    document.body.appendChild(a);
    a.click();
});

// ==== Excel Functions ==== //

// Download Excel Template
downloadTemplateBtn.addEventListener('click', () => {
    const templateData = [
        {
            'ç»åº¦ (Longitude)': 120.38,
            'çº¬åº¦ (Latitude)': 36.07,
            'åç§° (Name)': 'ç¤ºä¾‹æ ‡è®°',
            'ç±»å‹ (Type)': 'shop',
            'åœ°å€ (Address)': 'å±±ä¸œçœé’å²›å¸‚å¸‚å—åŒº',
            'æ ‡è®°é¢œè‰² (marker-color)': '#4a90e2',
            'æ ‡è®°ç¬¦å· (marker-symbol)': 'shop'
        }
    ];

    const ws = XLSX.utils.json_to_sheet(templateData);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'æ ‡è®°æ•°æ®');
    XLSX.writeFile(wb, 'åœ°å›¾æ ‡è®°å¯¼å…¥æ¨¡æ¿.xlsx');
});

// Export to Excel with all fields
exportExcelBtn.addEventListener('click', () => {
    const data = [];
    drawnItems.eachLayer(l => {
        if (l instanceof L.Marker) {
            const ll = l.getLatLng();
            const props = l.feature?.properties || {};
            data.push({
                'ç»åº¦ (Longitude)': ll.lng,
                'çº¬åº¦ (Latitude)': ll.lat,
                'åç§° (Name)': props.name || '',
                'ç±»å‹ (Type)': props.type || '',
                'åœ°å€ (Address)': props.address || '',
                'æ ‡è®°é¢œè‰² (marker-color)': props['marker-color'] || '#4a90e2',
                'æ ‡è®°ç¬¦å· (marker-symbol)': props['marker-symbol'] || 'default'
            });
        }
    });

    if (data.length === 0) {
        alert('æ²¡æœ‰æ ‡è®°å¯å¯¼å‡º');
        return;
    }

    const ws = XLSX.utils.json_to_sheet(data);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'æ ‡è®°æ•°æ®');
    XLSX.writeFile(wb, 'åœ°å›¾æ ‡è®°æ•°æ®.xlsx');
});

// Import from Excel
excelFileInput.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = ev => {
        try {
            const data = new Uint8Array(ev.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const rows = XLSX.utils.sheet_to_json(firstSheet);

            let addedCount = 0;
            rows.forEach(row => {
                // Support multiple column name formats
                const lng = row['ç»åº¦ (Longitude)'] || row['Longitude'] || row['lng'] || row['ç»åº¦'];
                const lat = row['çº¬åº¦ (Latitude)'] || row['Latitude'] || row['lat'] || row['çº¬åº¦'];

                if (!lng || !lat || isNaN(parseFloat(lng)) || isNaN(parseFloat(lat))) {
                    return;
                }

                const properties = {
                    name: row['åç§° (Name)'] || row['Name'] || row['name'] || row['åç§°'] || 'æœªå‘½å',
                    type: row['ç±»å‹ (Type)'] || row['Type'] || row['type'] || row['ç±»å‹'] || '',
                    address: row['åœ°å€ (Address)'] || row['Address'] || row['address'] || row['åœ°å€'] || '',
                    'marker-color': row['æ ‡è®°é¢œè‰² (marker-color)'] || row['marker-color'] || row['color'] || '#4a90e2',
                    'marker-symbol': row['æ ‡è®°ç¬¦å· (marker-symbol)'] || row['marker-symbol'] || row['symbol'] || 'default'
                };

                const icon = getMarkerIcon(properties);
                const marker = L.marker([parseFloat(lat), parseFloat(lng)], { icon });
                marker.feature = { properties };

                // Bind popup
                const latlng = marker.getLatLng();
                const popupHtml = `<h3>${properties.name}</h3>` +
                    `<p>ç±»å‹: ${properties.type}<br>åœ°å€: ${properties.address}<br>` +
                    `ç»çº¬åº¦: ${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)} ` +
                    `<button onclick="navigator.clipboard.writeText('${latlng.lat},${latlng.lng}')">å¤åˆ¶</button></p>`;
                marker.bindPopup(popupHtml);

                bindMarkerContextMenu(marker);
                drawnItems.addLayer(marker);
                addedCount++;
            });

            if (addedCount > 0) {
                updateLayerList();
                map.fitBounds(drawnItems.getBounds());
                alert(`æˆåŠŸå¯¼å…¥ ${addedCount} ä¸ªæ ‡è®°`);
            } else {
                alert('æœªæ‰¾åˆ°æœ‰æ•ˆçš„åæ ‡æ•°æ®');
            }
        } catch (err) {
            console.error(err);
            alert('Excel æ–‡ä»¶è§£æå¤±è´¥ï¼š' + err.message);
        }
    };
    reader.readAsArrayBuffer(file);
});

// Enhanced Coord Import with PapaParse and Type Detection
coordFileInput.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;

    Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        complete: function (results) {
            const rows = results.data;
            let addedCount = 0;

            rows.forEach(row => {
                let lat, lng;

                const latKeys = ['çº¬åº¦', 'Latitude', 'lat', 'latitude', 'çº¬åº¦ (Latitude)'];
                const lngKeys = ['ç»åº¦', 'Longitude', 'lng', 'longitude', 'ç»åº¦ (Longitude)'];

                for (const key of latKeys) {
                    if (row[key]) { lat = parseFloat(row[key]); break; }
                }
                for (const key of lngKeys) {
                    if (row[key]) { lng = parseFloat(row[key]); break; }
                }

                if (!isNaN(lat) && !isNaN(lng)) {
                    const name = row['é—¨åº—'] || row['name'] || row['Name'] || row['åç§°'] || 'æœªå‘½å';
                    const type = row['ç±»å‹'] || row['type'] || row['Type'] || '';
                    const address = row['åœ°å€'] || row['address'] || row['Address'] || '';

                    const properties = {
                        name: name,
                        type: type,
                        address: address
                    };

                    const icon = getMarkerIcon(properties);
                    const marker = L.marker([lat, lng], { icon: icon });

                    marker.feature = { properties: properties };

                    let popupContent = `< b > ${name}</b > `;
                    if (type) popupContent += `< br > ç±»å‹: ${type} `;
                    if (address) popupContent += `< br > åœ°å€: ${address} `;
                    marker.bindPopup(popupContent);

                    bindMarkerContextMenu(marker);
                    drawnItems.addLayer(marker);
                    addedCount++;
                }
            });

            if (addedCount > 0) {
                updateLayerList();
                map.fitBounds(drawnItems.getBounds());
                alert(`æˆåŠŸå¯¼å…¥ ${addedCount} ä¸ªæ ‡è®°`);
            } else {
                alert('æœªæ‰¾åˆ°æœ‰æ•ˆçš„åæ ‡æ•°æ®ï¼Œè¯·æ£€æŸ¥ CSV æ–‡ä»¶æ ¼å¼');
            }
        },
        error: function (err) {
            alert('CSV è§£æå¤±è´¥: ' + err.message);
        }
    });
});

if (addressFileInput) {
    addressFileInput.addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = async ev => {
            const rows = Papa.parse(ev.target.result, { header: true }).data;
            for (const row of rows) {
                const address = row.address || row.Address || row.åœ°å€;
                if (!address) continue;
                try {
                    const resp = await fetch(`${AMAP_GEOCODE_URL}?key=${AMAP_API_KEY}&address=${encodeURIComponent(address)}`);
                    const data = await resp.json();
                    if (data.geocodes && data.geocodes.length) {
                        const [lng, lat] = data.geocodes[0].location.split(',');
                        const icon = createCustomMarkerIcon('#4a90e2', 'default');
                        const marker = L.marker([parseFloat(lat), parseFloat(lng)], { icon });
                        marker.feature = { properties: { name: address } };
                        bindMarkerContextMenu(marker);
                        drawnItems.addLayer(marker);
                    }
                } catch (err) {
                    console.error(err);
                }
            }
            updateLayerList();
            if (drawnItems.getLayers().length) map.fitBounds(drawnItems.getBounds());
        };
        reader.readAsText(file);
    });
}


togglePickerBtn.addEventListener('click', () => {
    pickerMode = !pickerMode;
    togglePickerBtn.textContent = pickerMode ? 'å…³é—­åæ ‡æ‹¾å–' : 'å¯ç”¨åæ ‡æ‹¾å–';
    pickedCoordsDiv.textContent = pickerMode ? 'ç‚¹å‡»åœ°å›¾æ‹¾å–åæ ‡...' : '';
    map.getContainer().style.cursor = pickerMode ? 'crosshair' : '';
});

addManualMarkerBtn.addEventListener('click', () => {
    manualMarkerMode = !manualMarkerMode;
    addManualMarkerBtn.textContent = manualMarkerMode ? 'å–æ¶ˆæ·»åŠ ' : 'ç‚¹å‡»åœ°å›¾æ·»åŠ ';
    map.getContainer().style.cursor = manualMarkerMode ? 'crosshair' : '';
});

// Layer panel toggle
toggleLayerPanelBtn.addEventListener('click', () => {
    const panel = document.getElementById('layerPanel');
    if (panel.style.display === 'none' || !panel.style.display) {
        panel.style.display = 'flex';
        toggleLayerPanelBtn.textContent = 'éšè—å›¾å±‚é¢æ¿';
    } else {
        panel.style.display = 'none';
        toggleLayerPanelBtn.textContent = 'æ˜¾ç¤ºå›¾å±‚é¢æ¿';
    }
});

searchBtn.addEventListener('click', async () => {
    const addr = searchAddressInput.value.trim();
    if (!addr) { alert('è¯·è¾“å…¥åœ°å€'); return; }
    try {
        const resp = await fetch(`${AMAP_GEOCODE_URL}?key=${AMAP_API_KEY}&address=${encodeURIComponent(addr)}`);
        const data = await resp.json();
        if (data.geocodes && data.geocodes.length) {
            const [lng, lat] = data.geocodes[0].location.split(',');
            const latN = parseFloat(lat), lngN = parseFloat(lng);
            map.setView([latN, lngN], 15);
            const icon = createCustomMarkerIcon('#4a90e2', 'default');
            const marker = L.marker([latN, lngN], { icon });
            marker.feature = { properties: { name: addr } };
            bindMarkerContextMenu(marker);
            drawnItems.addLayer(marker);
            updateLayerList();
        } else {
            alert('æœªæ‰¾åˆ°è¯¥åœ°å€');
        }
    } catch (e) {
        console.error(e);
        alert('æœç´¢å¤±è´¥');
    }
});

gotoCoordBtn.addEventListener('click', () => {
    const lat = parseFloat(gotoLatInput.value);
    const lng = parseFloat(gotoLngInput.value);
    if (isNaN(lat) || isNaN(lng)) { alert('è¯·è¾“å…¥æœ‰æ•ˆåæ ‡'); return; }
    map.setView([lat, lng], 15);
    const icon = createCustomMarkerIcon('#4a90e2', 'default');
    const marker = L.marker([lat, lng], { icon });
    marker.feature = { properties: { name: `åæ ‡: ${lat.toFixed(6)}, ${lng.toFixed(6)} ` } };
    bindMarkerContextMenu(marker);
    drawnItems.addLayer(marker);
    updateLayerList();
});

map.on('click', e => {
    if (pickerMode) {
        const lat = e.latlng.lat.toFixed(6);
        const lng = e.latlng.lng.toFixed(6);
        pickedCoordsDiv.textContent = `çº¬åº¦: ${lat}, ç»åº¦: ${lng} `;
        if (navigator.clipboard) navigator.clipboard.writeText(`${lat},${lng} `);
        return;
    }
    if (manualMarkerMode) {
        const note = manualNoteInput.value.trim() || 'æ— å¤‡æ³¨';
        const icon = createCustomMarkerIcon('#4a90e2', 'default');
        const marker = L.marker(e.latlng, { icon });
        marker.feature = { properties: { name: note } };
        bindMarkerContextMenu(marker);
        drawnItems.addLayer(marker);
        manualNoteInput.value = '';
        manualMarkerMode = false;
        addManualMarkerBtn.textContent = 'ç‚¹å‡»åœ°å›¾æ·»åŠ ';
        map.getContainer().style.cursor = '';
        updateLayerList();
        return;
    }
});

// ==== Global Functions for Layer Management ==== //
window.toggleLayerVisibility = function (id) {
    drawnItems.eachLayer(l => {
        if (l._leaflet_id === id) {
            if (map.hasLayer(l)) map.removeLayer(l); else map.addLayer(l);
        }
    });
};
window.renameLayer = function (id) {
    drawnItems.eachLayer(l => {
        if (l._leaflet_id === id) {
            const newName = prompt('è¾“å…¥æ–°åç§°ï¼š', l.options.name || '');
            if (newName !== null) {
                l.options.name = newName;
                if (!l.feature) l.feature = { properties: {} };
                l.feature.properties.name = newName;
                updateLayerList();
                updateLabels();
            }
        }
    });
};
window.deleteLayer = function (id) {
    drawnItems.eachLayer(l => {
        if (l._leaflet_id === id) {
            drawnItems.removeLayer(l);
            updateLayerList();
        }
    });
};

// ==== Expose Context Menu Functions ==== //
window.editMarkerProperties = editMarkerProperties;
window.changeMarkerIcon = changeMarkerIcon;
window.deleteSelectedMarker = deleteSelectedMarker;
window.openEventTrackerFromMenu = openEventTrackerFromMenu;

// ==== Global Event Tracker Functions (for onclick) ==== //
window.closeEventTracker = function () {
    console.log('closeEventTracker called');
    if (currentTrackedFeature && currentTrackedFeature._eventId) {
        const eventData = currentTrackedFeature._currentEventData || initEventData();
        eventData.notes = eventNotes.value;
        setEventData(currentTrackedFeature._eventId, eventData);
        console.log('Event data auto-saved on close');
    }
    eventTrackerPanel.style.display = 'none';
    currentTrackedFeature = null;
    alert('é¢æ¿å·²å…³é—­');
};

window.saveEventData = function () {
    console.log('saveEventData called');
    if (!currentTrackedFeature) {
        alert('æ²¡æœ‰é€‰ä¸­çš„å›¾å±‚');
        return;
    }
    const eventData = currentTrackedFeature._currentEventData || initEventData();
    eventData.notes = eventNotes.value;
    setEventData(currentTrackedFeature._eventId, eventData);
    alert('âœ… äº‹ä»¶æ•°æ®å·²ä¿å­˜ï¼');
};


// ==== Event Tracker System (Multi-Event Support) ==== //

// Get all events for a marker (from feature properties)
function getMarkerEvents(feature) {
    if (!feature) return [];
    // Ensure feature structure exists
    if (!feature.feature) {
        feature.feature = { type: 'Feature', properties: {}, geometry: null };
    }
    if (!feature.feature.properties) {
        feature.feature.properties = {};
    }
    return feature.feature.properties.events || [];
}

// Save all events for a marker (to feature properties)
function saveMarkerEvents(feature, events) {
    if (!feature) return;
    // Ensure feature structure exists
    if (!feature.feature) {
        feature.feature = { type: 'Feature', properties: {}, geometry: null };
    }
    if (!feature.feature.properties) {
        feature.feature.properties = {};
    }
    feature.feature.properties.events = events;

    // Update GeoJSON editor to reflect changes
    updateGeoJSONEditor();
    console.log('Events saved to feature:', events.length);
}

// Open event tracker for a feature - shows event list
function openEventTracker(feature) {
    currentTrackedFeature = feature;
    currentEditingEventId = null;

    // Load data into UI
    const featureName = feature.options?.name || feature.feature?.properties?.name || 'æœªå‘½åç‰¹å¾';
    eventTrackerFeatureName.textContent = `ğŸ“ ${featureName}`;

    // Show list view, hide edit view
    showEventList();

    // Show panel
    eventTrackerPanel.style.display = 'flex';
    console.log('Event tracker opened');
}


// Show event list view
function showEventList() {
    document.getElementById('eventListView').style.display = 'flex';
    document.getElementById('eventEditView').style.display = 'none';

    renderEventList();
}

// Render the event list
function renderEventList() {
    const container = document.getElementById('eventListContainer');
    if (!currentTrackedFeature) return;

    const events = getMarkerEvents(currentTrackedFeature);

    if (events.length === 0) {
        container.innerHTML = `
            <div class="empty-state">
                <p>ğŸ“‹ æš‚æ— äº‹ä»¶</p>
                <p>ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®æ·»åŠ ç¬¬ä¸€ä¸ªäº‹ä»¶</p>
            </div>
        `;
        return;
    }

    // Sort by date (newest first)
    const sortedEvents = [...events].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

    container.innerHTML = sortedEvents.map(event => `
        <div class="event-card" onclick="editEvent('${event.id}')">
            <div class="event-card-info">
                <div class="event-card-date">${formatEventDate(event.createdAt)}</div>
                <div class="event-card-name">${event.name || 'æœªå‘½åäº‹ä»¶'}</div>
            </div>
            <div class="event-card-actions">
                <button class="btn-edit" onclick="event.stopPropagation(); editEvent('${event.id}')">ç¼–è¾‘</button>
                <button class="btn-delete" onclick="event.stopPropagation(); deleteEvent('${event.id}')">åˆ é™¤</button>
            </div>
        </div>
    `).join('');
}

// Format event date for display
function formatEventDate(dateString) {
    if (!dateString) return 'æœªçŸ¥æ—¥æœŸ';
    const d = new Date(dateString);
    return d.toLocaleDateString('zh-CN', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
    }).replace(/\//g, '-');
}

// Create new event
function createNewEvent() {
    if (!currentTrackedFeature) return;

    const newEvent = {
        id: generateEventId(),
        name: '',
        createdAt: new Date().toISOString(),
        todos: [],
        notes: '',
        urls: [],
        timeline: []
    };

    // Add to events list
    const events = getMarkerEvents(currentTrackedFeature);
    events.push(newEvent);
    saveMarkerEvents(currentTrackedFeature, events);

    // Open edit view
    editEvent(newEvent.id);

}

// Edit an event
function editEvent(eventId) {
    if (!currentTrackedFeature) return;

    currentEditingEventId = eventId;
    const events = getMarkerEvents(currentTrackedFeature);
    const event = events.find(e => e.id === eventId);

    if (!event) {
        alert('äº‹ä»¶æœªæ‰¾åˆ°');
        return;
    }

    // Store current event data
    currentTrackedFeature._currentEventData = event;

    // Switch to edit view
    document.getElementById('eventListView').style.display = 'none';
    document.getElementById('eventEditView').style.display = 'flex';

    // Load event data into form
    document.getElementById('currentEventName').value = event.name || '';
    eventNotes.value = event.notes || '';
    renderTodoList(event.todos || []);
    renderUrlList(event.urls || []);
    renderTimeline(event.timeline || []);
    renderAttachmentList(event.attachments || []);
}


// Delete an event
function deleteEvent(eventId) {
    if (!currentTrackedFeature) return;

    if (!confirm('ç¡®å®šåˆ é™¤æ­¤äº‹ä»¶ï¼Ÿ')) return;

    const events = getMarkerEvents(currentTrackedFeature);
    const index = events.findIndex(e => e.id === eventId);

    if (index !== -1) {
        events.splice(index, 1);
        saveMarkerEvents(currentTrackedFeature, events);
        renderEventList();
    }

}

// Save current event
function saveCurrentEvent() {
    if (!currentTrackedFeature || !currentEditingEventId) {
        console.log('æ²¡æœ‰æ­£åœ¨ç¼–è¾‘çš„äº‹ä»¶');
        return;
    }

    const events = getMarkerEvents(currentTrackedFeature);
    const eventIndex = events.findIndex(e => e.id === currentEditingEventId);

    if (eventIndex === -1) {
        console.log('äº‹ä»¶æœªæ‰¾åˆ°');
        return;
    }

    // Update event data
    events[eventIndex].name = document.getElementById('currentEventName').value || 'æœªå‘½åäº‹ä»¶';
    events[eventIndex].notes = eventNotes.value;
    events[eventIndex].todos = currentTrackedFeature._currentEventData?.todos || [];
    events[eventIndex].urls = currentTrackedFeature._currentEventData?.urls || [];
    events[eventIndex].timeline = currentTrackedFeature._currentEventData?.timeline || [];
    events[eventIndex].attachments = currentTrackedFeature._currentEventData?.attachments || [];

    saveMarkerEvents(currentTrackedFeature, events);


    // Visual feedback without blocking alert

    const btn = document.getElementById('saveEventDataBtn');
    if (btn) {
        const originalText = btn.textContent;
        btn.textContent = 'âœ… å·²ä¿å­˜';
        btn.style.background = '#2ecc71';
        setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '';
        }, 1500);
    }
    console.log('äº‹ä»¶å·²ä¿å­˜');
}


// Make functions globally accessible
window.createNewEvent = createNewEvent;
window.editEvent = editEvent;
window.deleteEvent = deleteEvent;
window.showEventList = showEventList;
window.saveCurrentEvent = saveCurrentEvent;

// Wrapper functions for onclick buttons
window.addTodoItemClick = function () { addTodoItem(); };
window.addUrlItemClick = function () { addUrlItem(); };
window.addTimelineEventClick = function () { addTimelineEvent(); };

// ==== Event Archive System ==== //

// Save events to a slot (includes marker info)
function saveEventSlot() {
    const slotSelect = document.getElementById('eventSlotSelect');
    if (!slotSelect) return;

    const slotKey = slotSelect.value;
    const eventArchive = [];

    // Iterate through all markers and collect events
    drawnItems.eachLayer(layer => {
        const events = getMarkerEvents(layer);
        if (events && events.length > 0) {
            // Get layer position
            let coords = null;
            if (layer.getLatLng) {
                const ll = layer.getLatLng();
                coords = { lat: ll.lat, lng: ll.lng };
            } else if (layer.getBounds) {
                const center = layer.getBounds().getCenter();
                coords = { lat: center.lat, lng: center.lng };
            }

            // Get layer name
            const name = layer.options?.name || layer.feature?.properties?.name || 'æœªå‘½å';

            eventArchive.push({
                name: name,
                coords: coords,
                events: events
            });
        }
    });

    if (eventArchive.length === 0) {
        console.log('æ²¡æœ‰äº‹ä»¶éœ€è¦ä¿å­˜');
        return;
    }

    localStorage.setItem(slotKey, JSON.stringify(eventArchive));

    // Visual feedback
    const btn = document.getElementById('saveEventSlotBtn');
    if (btn) {
        const originalText = btn.textContent;
        btn.textContent = 'âœ… å·²ä¿å­˜';
        setTimeout(() => { btn.textContent = originalText; }, 1500);
    }
    console.log(`äº‹ä»¶å­˜æ¡£å·²ä¿å­˜åˆ° ${slotKey}:`, eventArchive.length, 'ä¸ªæ ‡è®°');
}

// Load events from a slot
function loadEventSlot() {
    const slotSelect = document.getElementById('eventSlotSelect');
    if (!slotSelect) return;

    const slotKey = slotSelect.value;
    const data = localStorage.getItem(slotKey);

    if (!data) {
        console.log('è¯¥å­˜æ¡£æ§½ä¸ºç©º');
        return;
    }

    const eventArchive = JSON.parse(data);
    let matchCount = 0;

    eventArchive.forEach(archive => {
        // Try to find matching layer by name + coords
        let matchedLayer = null;

        drawnItems.eachLayer(layer => {
            if (matchedLayer) return;

            const layerName = layer.options?.name || layer.feature?.properties?.name || 'æœªå‘½å';

            // Match by name first
            if (layerName === archive.name) {
                // Verify by coordinates proximity
                let layerCoords = null;
                if (layer.getLatLng) {
                    const ll = layer.getLatLng();
                    layerCoords = { lat: ll.lat, lng: ll.lng };
                } else if (layer.getBounds) {
                    const center = layer.getBounds().getCenter();
                    layerCoords = { lat: center.lat, lng: center.lng };
                }

                if (layerCoords && archive.coords) {
                    const dist = Math.sqrt(
                        Math.pow(layerCoords.lat - archive.coords.lat, 2) +
                        Math.pow(layerCoords.lng - archive.coords.lng, 2)
                    );
                    if (dist < 0.001) { // ~100m tolerance
                        matchedLayer = layer;
                    }
                }
            }
        });

        if (matchedLayer) {
            // Restore events to matched layer
            saveMarkerEvents(matchedLayer, archive.events);
            matchCount++;
        }
    });

    // Visual feedback
    const btn = document.getElementById('loadEventSlotBtn');
    if (btn) {
        const originalText = btn.textContent;
        btn.textContent = `âœ… å·²åŠ è½½ ${mathCount}`;
        setTimeout(() => { btn.textContent = originalText; }, 1500);
    }
    console.log(`ä» ${slotKey} åŠ è½½äº‹ä»¶:`, matchCount, '/', eventArchive.length, 'åŒ¹é…');
}

window.saveEventSlot = saveEventSlot;
window.loadEventSlot = loadEventSlot;

// ==== Complete Archive System (Simplified) ==== //

// Save complete archive (layers + events as GeoJSON)
function saveCompleteSlot() {
    const slotSelect = document.getElementById('completeSlotSelect');
    if (!slotSelect) return;

    const slotKey = slotSelect.value;

    // Export current layers as GeoJSON with events in properties
    const geojson = {
        type: 'FeatureCollection',
        features: []
    };

    drawnItems.eachLayer(layer => {
        if (layer.toGeoJSON) {
            const feature = layer.toGeoJSON();
            // Events are already in feature.properties.events (from saveMarkerEvents)
            geojson.features.push(feature);
        }
    });

    localStorage.setItem(slotKey, JSON.stringify(geojson));

    // Visual feedback
    const btn = document.getElementById('saveCompleteBtn');
    if (btn) {
        const originalText = btn.textContent;
        btn.textContent = 'âœ… å·²ä¿å­˜';
        setTimeout(() => { btn.textContent = originalText; }, 1500);
    }
    console.log(`å®Œæ•´å­˜æ¡£å·²ä¿å­˜åˆ° ${slotKey}:`, geojson.features.length, 'ä¸ªå›¾å±‚');
}

// Load complete archive
function loadCompleteSlot() {
    const slotSelect = document.getElementById('completeSlotSelect');
    if (!slotSelect) return;

    const slotKey = slotSelect.value;
    const data = localStorage.getItem(slotKey);

    if (!data) {
        console.log('è¯¥å­˜æ¡£æ§½ä¸ºç©º');
        return;
    }

    // Clear current layers
    drawnItems.clearLayers();

    // Import GeoJSON (events are in properties.events)
    importGeoJSON(data);

    // Visual feedback
    const btn = document.getElementById('loadCompleteBtn');
    if (btn) {
        const originalText = btn.textContent;
        btn.textContent = 'âœ… å·²è¯»å–';
        setTimeout(() => { btn.textContent = originalText; }, 1500);
    }
    console.log(`ä» ${slotKey} è¯»å–å®Œæ•´å­˜æ¡£`);
}

window.saveCompleteSlot = saveCompleteSlot;
window.loadCompleteSlot = loadCompleteSlot;

// ==== Unlimited Named Archive System ==== //
const ARCHIVE_LIST_KEY = 'archive_list';
let currentArchiveId = null;

// Get archive list
function getArchiveList() {
    const data = localStorage.getItem(ARCHIVE_LIST_KEY);
    return data ? JSON.parse(data) : [];
}

// Save archive list
function saveArchiveList(list) {
    localStorage.setItem(ARCHIVE_LIST_KEY, JSON.stringify(list));
}

// Render archive list UI
function renderArchiveList() {
    const container = document.getElementById('archiveList');
    if (!container) return;

    const archives = getArchiveList();

    if (archives.length === 0) {
        container.innerHTML = '<p style="color:#666;font-size:0.8rem;text-align:center;">æš‚æ— å­˜æ¡£</p>';
        return;
    }

    container.innerHTML = archives.map(arc => `
        <div class="archive-item">
            <span class="archive-item-name">ğŸ“ ${arc.name}</span>
            <span class="archive-item-date">${arc.created}</span>
            <div class="archive-item-actions">
                <button class="load-btn" onclick="loadArchive('${arc.id}')">è¯»å–</button>
                <button class="delete-btn" onclick="deleteArchive('${arc.id}')">åˆ é™¤</button>
            </div>
        </div>
    `).join('');
}

// Create new archive
function createArchive() {
    const nameInput = document.getElementById('newArchiveName');
    const name = nameInput?.value.trim();

    if (!name) {
        nameInput?.focus();
        return;
    }

    const id = 'arc_' + Date.now();
    const created = new Date().toLocaleDateString('zh-CN');

    // Save archive data
    const geojson = {
        type: 'FeatureCollection',
        features: []
    };
    drawnItems.eachLayer(layer => {
        if (layer.toGeoJSON) {
            geojson.features.push(layer.toGeoJSON());
        }
    });
    localStorage.setItem(id, JSON.stringify(geojson));

    // Update archive list
    const list = getArchiveList();
    list.unshift({ id, name, created });
    saveArchiveList(list);

    // Clear input and refresh
    nameInput.value = '';
    renderArchiveList();

    // Set as current
    currentArchiveId = id;
    updateCurrentArchiveInfo(name);

    console.log('åˆ›å»ºå­˜æ¡£:', name);
}

// Load archive
function loadArchive(id) {
    const data = localStorage.getItem(id);
    if (!data) {
        console.log('å­˜æ¡£ä¸å­˜åœ¨');
        return;
    }

    drawnItems.clearLayers();
    importGeoJSON(data);

    // Update current archive
    const list = getArchiveList();
    const arc = list.find(a => a.id === id);
    currentArchiveId = id;
    updateCurrentArchiveInfo(arc?.name || 'æœªçŸ¥');

    console.log('åŠ è½½å­˜æ¡£:', arc?.name);
}

// Delete archive
function deleteArchive(id) {
    if (!confirm('ç¡®å®šåˆ é™¤æ­¤å­˜æ¡£ï¼Ÿ')) return;

    localStorage.removeItem(id);

    const list = getArchiveList().filter(a => a.id !== id);
    saveArchiveList(list);

    if (currentArchiveId === id) {
        currentArchiveId = null;
        document.getElementById('currentArchiveInfo').style.display = 'none';
    }

    renderArchiveList();
}

// Save to current archive
function saveCurrentArchive() {
    if (!currentArchiveId) return;

    const geojson = {
        type: 'FeatureCollection',
        features: []
    };
    drawnItems.eachLayer(layer => {
        if (layer.toGeoJSON) {
            geojson.features.push(layer.toGeoJSON());
        }
    });
    localStorage.setItem(currentArchiveId, JSON.stringify(geojson));

    // Visual feedback
    const btn = document.querySelector('#currentArchiveInfo button');
    if (btn) {
        const originalText = btn.textContent;
        btn.textContent = 'âœ… å·²ä¿å­˜';
        setTimeout(() => { btn.textContent = originalText; }, 1500);
    }
}

// Update current archive info display
function updateCurrentArchiveInfo(name) {
    const info = document.getElementById('currentArchiveInfo');
    const nameEl = document.getElementById('currentArchiveName');
    if (info && nameEl) {
        nameEl.textContent = name;
        info.style.display = 'flex';
    }
}

// Initialize archive list on page load
setTimeout(renderArchiveList, 100);

window.createArchive = createArchive;
window.loadArchive = loadArchive;
window.deleteArchive = deleteArchive;
window.saveCurrentArchive = saveCurrentArchive;

// ==== Attachment System ==== //
const MAX_ATTACHMENT_SIZE = 500 * 1024; // 500KB

// Upload attachment
function uploadAttachment() {
    const input = document.getElementById('attachmentInput');
    if (!input?.files?.length) return;

    const file = input.files[0];

    if (file.size > MAX_ATTACHMENT_SIZE) {
        console.log('æ–‡ä»¶å¤ªå¤§ï¼Œæœ€å¤§æ”¯æŒ500KB');
        input.value = '';
        return;
    }

    if (!currentTrackedFeature || !currentEditingEventId) {
        console.log('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªäº‹ä»¶');
        input.value = '';
        return;
    }

    const reader = new FileReader();
    reader.onload = function (e) {
        const attachment = {
            id: 'att_' + Date.now(),
            name: file.name,
            type: file.type,
            size: file.size,
            data: e.target.result
        };

        const eventData = currentTrackedFeature._currentEventData;
        if (!eventData.attachments) eventData.attachments = [];
        eventData.attachments.push(attachment);

        renderAttachmentList(eventData.attachments);
        input.value = '';

        console.log('é™„ä»¶å·²ä¸Šä¼ :', file.name);
    };
    reader.readAsDataURL(file);
}

// Render attachment list
function renderAttachmentList(attachments) {
    const container = document.getElementById('attachmentList');
    if (!container) return;

    if (!attachments || attachments.length === 0) {
        container.innerHTML = '';
        return;
    }

    container.innerHTML = attachments.map((att, index) => {
        const icon = getAttachmentIcon(att.type);
        const size = formatFileSize(att.size);
        return `
            <div class="attachment-item">
                <div class="attachment-item-info">
                    <span class="attachment-item-icon">${icon}</span>
                    <span class="attachment-item-name">${att.name}</span>
                    <span class="attachment-item-size">(${size})</span>
                </div>
                <div class="attachment-item-actions">
                    <button onclick="downloadAttachment(${index})">ä¸‹è½½</button>
                    <button class="delete-btn" onclick="deleteAttachment(${index})">åˆ é™¤</button>
                </div>
            </div>
        `;
    }).join('');
}

// Get icon for attachment type
function getAttachmentIcon(type) {
    if (type.startsWith('image/')) return 'ğŸ–¼ï¸';
    if (type === 'application/pdf') return 'ğŸ“„';
    if (type.includes('word')) return 'ğŸ“';
    if (type.includes('excel') || type.includes('spreadsheet')) return 'ğŸ“Š';
    return 'ğŸ“';
}

// Format file size
function formatFileSize(bytes) {
    if (bytes < 1024) return bytes + 'B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + 'KB';
    return (bytes / (1024 * 1024)).toFixed(1) + 'MB';
}

// Download attachment
function downloadAttachment(index) {
    const eventData = currentTrackedFeature?._currentEventData;
    if (!eventData?.attachments?.[index]) return;

    const att = eventData.attachments[index];
    const link = document.createElement('a');
    link.href = att.data;
    link.download = att.name;
    link.click();
}

// Delete attachment
function deleteAttachment(index) {
    const eventData = currentTrackedFeature?._currentEventData;
    if (!eventData?.attachments) return;

    eventData.attachments.splice(index, 1);
    renderAttachmentList(eventData.attachments);
}

window.uploadAttachment = uploadAttachment;
window.downloadAttachment = downloadAttachment;
window.deleteAttachment = deleteAttachment;

// ==== Code Editor Archive System ==== //
const CODE_ARCHIVE_LIST_KEY = 'code_archive_list';
let currentCodeArchiveId = null;

function getCodeArchiveList() {
    const data = localStorage.getItem(CODE_ARCHIVE_LIST_KEY);
    return data ? JSON.parse(data) : [];
}

function saveCodeArchiveList(list) {
    localStorage.setItem(CODE_ARCHIVE_LIST_KEY, JSON.stringify(list));
}

function renderCodeArchiveList() {
    const container = document.getElementById('codeArchiveList');
    if (!container) return;

    const archives = getCodeArchiveList();

    if (archives.length === 0) {
        container.innerHTML = '<p style="color:#666;font-size:0.8rem;text-align:center;">æš‚æ— ä»£ç å­˜æ¡£</p>';
        return;
    }

    container.innerHTML = archives.map(arc => `
        <div class="archive-item">
            <span class="archive-item-name">ğŸ“ ${arc.name}</span>
            <span class="archive-item-date">${arc.created}</span>
            <div class="archive-item-actions">
                <button class="load-btn" onclick="loadCodeArchive('${arc.id}')">è¯»å–</button>
                <button class="delete-btn" onclick="deleteCodeArchive('${arc.id}')">åˆ é™¤</button>
            </div>
        </div>
    `).join('');
}

function createCodeArchive() {
    const nameInput = document.getElementById('newCodeArchiveName');
    const name = nameInput?.value.trim();

    if (!name) {
        nameInput?.focus();
        return;
    }

    const id = 'code_arc_' + Date.now();
    const created = new Date().toLocaleDateString('zh-CN');

    // Save current editor content
    const content = geojsonEditor?.value || '';
    localStorage.setItem(id, content);

    const list = getCodeArchiveList();
    list.unshift({ id, name, created });
    saveCodeArchiveList(list);

    nameInput.value = '';
    renderCodeArchiveList();

    currentCodeArchiveId = id;
    updateCurrentCodeArchiveInfo(name);

    console.log('åˆ›å»ºä»£ç å­˜æ¡£:', name);
}

function loadCodeArchive(id) {
    const data = localStorage.getItem(id);
    if (data === null) {
        console.log('ä»£ç å­˜æ¡£ä¸å­˜åœ¨');
        return;
    }

    if (geojsonEditor) {
        geojsonEditor.value = data;
    }

    const list = getCodeArchiveList();
    const arc = list.find(a => a.id === id);
    currentCodeArchiveId = id;
    updateCurrentCodeArchiveInfo(arc?.name || 'æœªçŸ¥');

    console.log('åŠ è½½ä»£ç å­˜æ¡£:', arc?.name);
}

function deleteCodeArchive(id) {
    if (!confirm('ç¡®å®šåˆ é™¤æ­¤ä»£ç å­˜æ¡£ï¼Ÿ')) return;

    localStorage.removeItem(id);

    const list = getCodeArchiveList().filter(a => a.id !== id);
    saveCodeArchiveList(list);

    if (currentCodeArchiveId === id) {
        currentCodeArchiveId = null;
        const info = document.getElementById('currentCodeArchiveInfo');
        if (info) info.style.display = 'none';
    }

    renderCodeArchiveList();
}

function saveCurrentCodeArchive() {
    if (!currentCodeArchiveId) return;

    const content = geojsonEditor?.value || '';
    localStorage.setItem(currentCodeArchiveId, content);

    const btn = document.querySelector('#currentCodeArchiveInfo button');
    if (btn) {
        const originalText = btn.textContent;
        btn.textContent = 'âœ… å·²ä¿å­˜';
        setTimeout(() => { btn.textContent = originalText; }, 1500);
    }
}

function updateCurrentCodeArchiveInfo(name) {
    const info = document.getElementById('currentCodeArchiveInfo');
    const nameEl = document.getElementById('currentCodeArchiveName');
    if (info && nameEl) {
        nameEl.textContent = name;
        info.style.display = 'flex';
    }
}

setTimeout(renderCodeArchiveList, 100);

window.createCodeArchive = createCodeArchive;
window.loadCodeArchive = loadCodeArchive;
window.deleteCodeArchive = deleteCodeArchive;
window.saveCurrentCodeArchive = saveCurrentCodeArchive;


// Close event tracker
if (closeEventTrackerBtn) {
    closeEventTrackerBtn.addEventListener('click', () => {
        // Auto-save before closing
        if (currentTrackedFeature && currentTrackedFeature._eventId) {
            const eventData = currentTrackedFeature._currentEventData || initEventData();
            eventData.notes = eventNotes.value;
            setEventData(currentTrackedFeature._eventId, eventData);
            console.log('Event data auto-saved on close');
        }
        eventTrackerPanel.style.display = 'none';
        currentTrackedFeature = null;
    });
} else {
    console.error('closeEventTrackerBtn not found!');
}

// Todo List Functions
function renderTodoList(todos) {
    todoList.innerHTML = '';
    todos.forEach((todo, index) => {
        const todoItem = document.createElement('div');
        todoItem.className = 'todo-item';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = todo.completed;
        checkbox.addEventListener('change', () => toggleTodoItem(index));

        const text = document.createElement('span');
        text.className = `todo-item-text${todo.completed ? ' completed' : ''}`;
        text.textContent = todo.text;

        const time = document.createElement('span');
        time.className = 'todo-item-time';
        const date = new Date(todo.created);
        time.textContent = `${date.getMonth() + 1}/${date.getDate()}`;

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'todo-item-delete';
        deleteBtn.textContent = 'åˆ é™¤';
        deleteBtn.addEventListener('click', () => deleteTodoItem(index));

        todoItem.appendChild(checkbox);
        todoItem.appendChild(text);
        todoItem.appendChild(time);
        todoItem.appendChild(deleteBtn);
        todoList.appendChild(todoItem);
    });
}

function addTodoItem() {
    if (!currentTrackedFeature) return;
    const text = newTodoInput.value.trim();
    if (!text) return;

    const eventData = currentTrackedFeature._currentEventData;
    if (!eventData.todos) eventData.todos = [];

    eventData.todos.push({
        id: Date.now(),
        text: text,
        completed: false,
        created: Date.now()
    });

    // Save to localStorage immediately
    setEventData(currentTrackedFeature._eventId, eventData);
    renderTodoList(eventData.todos);
    newTodoInput.value = '';
}

function toggleTodoItem(index) {
    if (!currentTrackedFeature) return;
    const eventData = currentTrackedFeature._currentEventData;
    eventData.todos[index].completed = !eventData.todos[index].completed;
    setEventData(currentTrackedFeature._eventId, eventData);
    renderTodoList(eventData.todos);
}

function deleteTodoItem(index) {
    if (!currentTrackedFeature) return;
    const eventData = currentTrackedFeature._currentEventData;
    eventData.todos.splice(index, 1);
    setEventData(currentTrackedFeature._eventId, eventData);
    renderTodoList(eventData.todos);
}



if (addTodoBtn) {
    addTodoBtn.addEventListener('click', addTodoItem);
} else {
    console.error('addTodoBtn not found!');
}

if (newTodoInput) {
    newTodoInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') addTodoItem();
    });
}


// URL Functions
function renderUrlList(urls) {
    urlList.innerHTML = '';
    urls.forEach((urlItem, index) => {
        const item = document.createElement('div');
        item.className = 'url-item';

        const link = document.createElement('a');
        link.href = urlItem.url;
        link.target = '_blank';
        link.textContent = urlItem.title || urlItem.url;

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'url-item-delete';
        deleteBtn.textContent = 'åˆ é™¤';
        deleteBtn.addEventListener('click'

            , () => deleteUrlItem(index));

        item.appendChild(link);
        item.appendChild(deleteBtn);
        urlList.appendChild(item);
    });
}

function addUrlItem() {
    if (!currentTrackedFeature) return;
    const title = urlTitle.value.trim();
    const url = urlAddress.value.trim();

    if (!url) {
        return;
    }


    const eventData = currentTrackedFeature._currentEventData;
    if (!eventData.urls) eventData.urls = [];

    eventData.urls.push({
        title: title || url,
        url: url,
        added: Date.now()
    });

    setEventData(currentTrackedFeature._eventId, eventData);
    renderUrlList(eventData.urls);
    urlTitle.value = '';
    urlAddress.value = '';
}

function deleteUrlItem(index) {
    if (!currentTrackedFeature) return;
    const eventData = currentTrackedFeature._currentEventData;
    eventData.urls.splice(index, 1);
    setEventData(currentTrackedFeature._eventId, eventData);
    renderUrlList(eventData.urls);
}



if (addUrlBtn) {
    addUrlBtn.addEventListener('click', addUrlItem);
} else {
    console.error('addUrlBtn not found!');
}


// Timeline Functions
function renderTimeline(events) {
    timelineDisplay.innerHTML = '';

    // Sort events by date (newest first)
    const sortedEvents = [...events].sort((a, b) => new Date(b.date) - new Date(a.date));

    sortedEvents.forEach((event, index) => {
        const eventEl = document.createElement('div');
        eventEl.className = 'timeline-event';

        const date = document.createElement('div');
        date.className = 'timeline-event-date';
        const d = new Date(event.date);
        const dateStr = d.toLocaleDateString('zh-CN', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
        });
        date.textContent = dateStr.replace(/\//g, '-');

        const title = document.createElement('div');
        title.className = 'timeline-event-title';
        title.textContent = event.title;

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'timeline-event-delete';
        deleteBtn.textContent = 'åˆ é™¤';
        deleteBtn.addEventListener('click', () => deleteTimelineEvent(events.findIndex(e => e.id === event.id)));

        eventEl.appendChild(date);
        eventEl.appendChild(title);
        if (event.description) {
            const desc = document.createElement('div');
            desc.className = 'timeline-event-description';
            desc.textContent = event.description;
            eventEl.appendChild(desc);
        }
        eventEl.appendChild(deleteBtn);

        timelineDisplay.appendChild(eventEl);
    });
}

function addTimelineEvent() {
    if (!currentTrackedFeature) return;
    const date = timelineDate.value;
    const title = timelineTitle.value.trim();

    if (!date || !title) {
        return;
    }


    const eventData = currentTrackedFeature._currentEventData;
    if (!eventData.timeline) eventData.timeline = [];

    eventData.timeline.push({
        id: Date.now(),
        date: date,
        title: title,
        description: '',
        type: 'event'
    });

    setEventData(currentTrackedFeature._eventId, eventData);
    renderTimeline(eventData.timeline);
    timelineDate.value = '';
    timelineTitle.value = '';
}

function deleteTimelineEvent(index) {
    if (!currentTrackedFeature) return;
    const eventData = currentTrackedFeature._currentEventData;
    eventData.timeline.splice(index, 1);
    setEventData(currentTrackedFeature._eventId, eventData);
    renderTimeline(eventData.timeline);
}


if (addTimelineBtn) {
    addTimelineBtn.addEventListener('click', addTimelineEvent);
} else {
    console.error('addTimelineBtn not found!');
}


// Save event data button
if (saveEventDataBtn) {
    saveEventDataBtn.addEventListener('click', () => {
        if (!currentTrackedFeature) {
            alert('æ²¡æœ‰é€‰ä¸­çš„å›¾å±‚');
            return;
        }

        const eventData = currentTrackedFeature._currentEventData;
        eventData.notes = eventNotes.value;
        setEventData(currentTrackedFeature._eventId, eventData);

        alert('âœ… äº‹ä»¶æ•°æ®å·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨ï¼\n\næ•°æ®ä¸å›¾å±‚åˆ†å¼€å­˜å‚¨ï¼Œåˆ·æ–°é¡µé¢åé‡æ–°æ‰“å¼€äº‹ä»¶è¿½è¸ªå™¨å³å¯æŸ¥çœ‹ã€‚');
    });
} else {
    console.error('saveEventDataBtn not found!');
}


// Add click handler to features to open event tracker
map.on('click', (e) => {
    // Check if click is on a layer
    let clickedLayer = null;
    drawnItems.eachLayer(layer => {
        if (layer instanceof L.Marker) {
            const latlng = layer.getLatLng();
            const distance = map.distance(e.latlng, latlng);
            if (distance < 50) { // 50 meters threshold
                clickedLayer = layer;
            }
        } else if (layer instanceof L.Polygon || layer instanceof L.Polyline || layer instanceof L.Circle) {
            // Check if click is inside polygon/circle
            try {
                if (layer.getBounds && layer.getBounds().contains(e.latlng)) {
                    clickedLayer = layer;
                }
            } catch (err) {
                // Ignore bounds errors
            }
        }
    });

    // If shift key is pressed and a layer is clicked, open event tracker
    if (e.originalEvent.shiftKey && clickedLayer) {
        e.originalEvent.preventDefault();
        openEventTracker(clickedLayer);
    }
});

// ==== Debug: Verify Event Tracker Elements ==== //
console.log('=== Event Tracker Elements Debug ===');
console.log('eventTrackerPanel:', eventTrackerPanel ? 'FOUND' : 'NOT FOUND');
console.log('closeEventTrackerBtn:', closeEventTrackerBtn ? 'FOUND' : 'NOT FOUND');
console.log('saveEventDataBtn:', saveEventDataBtn ? 'FOUND' : 'NOT FOUND');
console.log('addTodoBtn:', addTodoBtn ? 'FOUND' : 'NOT FOUND');
console.log('addUrlBtn:', addUrlBtn ? 'FOUND' : 'NOT FOUND');
console.log('addTimelineBtn:', addTimelineBtn ? 'FOUND' : 'NOT FOUND');
console.log('===================================');

// ==== CRITICAL: Define Global Functions at End of Script ==== //
function closeEventTracker() {
    console.log('closeEventTracker() called!');
    try {
        // Auto-save current event if editing
        if (currentTrackedFeature && currentEditingEventId) {
            const events = getMarkerEvents(currentTrackedFeature);
            const eventIndex = events.findIndex(e => e.id === currentEditingEventId);
            if (eventIndex !== -1 && currentTrackedFeature._currentEventData) {
                events[eventIndex].name = document.getElementById('currentEventName')?.value || 'æœªå‘½åäº‹ä»¶';
                events[eventIndex].notes = eventNotes?.value || '';
                events[eventIndex].todos = currentTrackedFeature._currentEventData.todos || [];
                events[eventIndex].urls = currentTrackedFeature._currentEventData.urls || [];
                events[eventIndex].timeline = currentTrackedFeature._currentEventData.timeline || [];
                saveMarkerEvents(currentTrackedFeature, events);
            }
        }
        document.getElementById('eventTrackerPanel').style.display = 'none';
        currentTrackedFeature = null;
        currentEditingEventId = null;
    } catch (e) {
        console.error('Error closing:', e);
    }
}

// Make sure functions are globally accessible
window.closeEventTracker = closeEventTracker;

console.log('Global functions defined:', typeof closeEventTracker, typeof saveCurrentEvent);

</script>
</body>

</html>
